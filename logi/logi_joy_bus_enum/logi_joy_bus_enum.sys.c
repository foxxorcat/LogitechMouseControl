/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void *__cdecl memmove(void *Dst, const void *Src, size_t MaxCount);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
LONG __fastcall sub_1400014D0(__int64 a1);
void __fastcall sub_14000151C(__int64 a1);
NTSTATUS __fastcall sub_140001540(__int64 a1, IRP *a2);
__int64 *__fastcall sub_14000155C(__int64 a1, int a2);
void __fastcall CsqAcquireLock(PIO_CSQ Csq, PKIRQL Irql);
void __fastcall CsqCompleteCanceledIrp(PIO_CSQ Csq, PIRP Irp);
void __fastcall CsqInsertIrp(struct _IO_CSQ *Csq, PIRP Irp);
struct _LIST_ENTRY **__fastcall CsqPeekNextIrp(PIO_CSQ Csq, PIRP Irp, struct _LIST_ENTRY *PeekContext);
void __fastcall CsqReleaseLock(PIO_CSQ Csq, KIRQL Irql);
void __fastcall CsqRemoveIrp(PIO_CSQ Csq, PIRP Irp);
__int64 __fastcall sub_1400016D4(__int64 a1, __int64 a2);
__int64 __fastcall sub_140001700(__int64 a1, __int64 a2);
void __fastcall sub_1400018EC(__int64 a1, __int64 a2);
__int64 *__fastcall sub_1400019B4(__int64 a1);
__int64 __fastcall sub_140001A24(__int64 a1, __int64 a2);
PIRP __fastcall sub_140001B10(__int64 a1);
void __fastcall sub_140001C4C(__int64 a1, const void *a2, unsigned int a3);
void __fastcall sub_140001D1C(__int64 a1, const void *a2, unsigned int a3);
void __fastcall sub_140001E04(__int64 a1, int *a2);
__int64 __fastcall sub_140001F0C(__int64 a1, IRP *a2, DWORD a3);
__int64 __fastcall sub_140002188(__int64 a1, IRP *a2);
__int64 __fastcall sub_1400023C0(__int64 a1, IRP *a2);
__int64 __fastcall sub_140002440(__int64 a1, IRP *a2);
__int64 __fastcall sub_140002484(__int64 a1, IRP *a2);
__int64 __fastcall sub_1400024E0(__int64 a1, IRP *a2);
__int64 __fastcall sub_140002524(__int64 a1, IRP *a2);
__int64 __fastcall sub_14000259C(__int64 a1, IRP *a2, __int64 a3);
__int64 __fastcall sub_1400026B8(__int64 a1, IRP *a2, __int64 a3);
__int64 __fastcall sub_140002780(__int64 a1, __int64 a2, struct _KEVENT *a3);
NTSTATUS __fastcall sub_1400027B0(__int64 a1);
void __fastcall sub_140002814(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000287C(__int64 a1, IRP *a2);
__int64 __fastcall sub_1400029F0(__int64 a1, __int64 a2);
void __fastcall sub_140002B60(__int64 a1, void *a2);
void __fastcall sub_140002BF4(__int64 a1);
void __fastcall CompletionFunction(PDEVICE_OBJECT DeviceObject, UCHAR MinorFunction, POWER_STATE PowerState, _QWORD *Context, PIO_STATUS_BLOCK IoStatus);
void __fastcall sub_140002D28(PDEVICE_OBJECT DeviceObject, UCHAR MinorFunction, POWER_STATE PowerState, _QWORD *Context, PIO_STATUS_BLOCK IoStatus);
void __fastcall sub_140002D88(PDEVICE_OBJECT DeviceObject, UCHAR MinorFunction, POWER_STATE PowerState, char *Context);
__int64 __fastcall sub_140002DAC(__int64 a1, IRP *a2);
// int swprintf(wchar_t *, const wchar_t *, ...);
__int64 __fastcall sub_140006000(__int64 a1, __int64 a2);
__int64 __fastcall nullsub_1(); // weak
__int64 __fastcall sub_14000607C(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400061F4(PDEVICE_OBJECT DeviceObject, _DWORD *Dst);
__int64 __fastcall sub_14000632C(struct _DEVICE_OBJECT *a1, IRP *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140006460(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400064AC(__int64 a1, __int64 a2);
__int64 __fastcall sub_140006578(__int64 a1, __int64 a2);
__int64 __fastcall sub_140006750(PVOID *a1, __int64 a2);
__int64 __fastcall sub_1400067E4(__int64 a1, __int64 a2);
NTSTATUS __fastcall sub_1400068B4(struct _DRIVER_OBJECT *a1, struct _DEVICE_OBJECT *a2);
NTSTATUS __fastcall sub_1400069F4(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140006C08(PDEVICE_OBJECT DeviceObject, PIRP Irp, __int64 a3, __int64 a4);
void __fastcall sub_140006DF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140006EA0(struct _DEVICE_OBJECT *a1, IRP *a2);
__int64 __fastcall sub_140006EF0(struct _UNICODE_STRING *a1);
__int64 __fastcall sub_140006F3C(PDEVICE_OBJECT DeviceObject, PVOID Tag, __int64 a3);
NTSTATUS __fastcall sub_140006FEC(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __fastcall sub_140007094(__int64 a1);
__int64 __fastcall sub_1400070C4(char *Context, PIRP Irp);
__int64 __fastcall sub_140007300(__int64 a1, IRP *a2);
__int64 __fastcall sub_1400073E4(__int64 a1, IRP *a2);
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath);

//-------------------------------------------------------------------------
// Data declarations

const CHAR File[288] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
// extern void (__stdcall *KeClearEvent)(PRKEVENT Event);
// extern LONG (__stdcall *KeSetEvent)(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// extern KIRQL (__stdcall *KeAcquireSpinLockRaiseToDpc)(PKSPIN_LOCK SpinLock);
// extern void (__stdcall *KeReleaseSpinLock)(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// extern NTSTATUS (__stdcall *IofCallDriver)(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// extern void (__stdcall *IofCompleteRequest)(PIRP Irp, CCHAR PriorityBoost);
// extern void (__stdcall *KeAcquireSpinLockAtDpcLevel)(PKSPIN_LOCK SpinLock);
// extern PVOID (__stdcall *ExAllocatePoolWithTag)(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// extern void (__stdcall *ExFreePoolWithTag)(PVOID P, ULONG Tag);
// extern void (__stdcall *MmBuildMdlForNonPagedPool)(PMDL MemoryDescriptorList);
// extern PIRP (__stdcall *IoAllocateIrp)(CCHAR StackSize, BOOLEAN ChargeQuota);
// extern PMDL (__stdcall *IoAllocateMdl)(PVOID VirtualAddress, ULONG Length, BOOLEAN SecondaryBuffer, BOOLEAN ChargeQuota, PIRP Irp);
// extern void (__stdcall *IoFreeIrp)(PIRP Irp);
// extern void (__stdcall *IoFreeMdl)(PMDL Mdl);
// extern void (__stdcall *IoReleaseCancelSpinLock)(KIRQL Irql);
// extern NTSTATUS (__stdcall *IoAcquireRemoveLockEx)(PIO_REMOVE_LOCK RemoveLock, PVOID Tag, PCSTR File, ULONG Line, ULONG RemlockSize);
// extern void (__stdcall *IoReleaseRemoveLockEx)(PIO_REMOVE_LOCK RemoveLock, PVOID Tag, ULONG RemlockSize);
// extern void (__stdcall *IoCsqInsertIrp)(PIO_CSQ Csq, PIRP Irp, PIO_CSQ_IRP_CONTEXT Context);
// extern PIRP (__stdcall *IoCsqRemoveNextIrp)(PIO_CSQ Csq, PVOID PeekContext);
// extern void (__stdcall *KeInitializeEvent)(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// extern NTSTATUS (__stdcall *KeWaitForSingleObject)(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// extern void (__stdcall *ExFreePool)(PVOID P);
// extern PIRP (__stdcall *IoBuildSynchronousFsdRequest)(ULONG MajorFunction, PDEVICE_OBJECT DeviceObject, PVOID Buffer, ULONG Length, PLARGE_INTEGER StartingOffset, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock);
// extern PDEVICE_OBJECT (__stdcall *IoGetAttachedDeviceReference)(PDEVICE_OBJECT DeviceObject);
// extern NTSTATUS (__stdcall *IoGetDeviceProperty)(PDEVICE_OBJECT DeviceObject, DEVICE_REGISTRY_PROPERTY DeviceProperty, ULONG BufferLength, PVOID PropertyBuffer, PULONG ResultLength);
// extern LONG_PTR (__stdcall *ObfReferenceObject)(PVOID Object);
// extern LONG_PTR (__stdcall *ObfDereferenceObject)(PVOID Object);
// extern PDEVICE_OBJECT (__stdcall *IoAttachDeviceToDeviceStack)(PDEVICE_OBJECT SourceDevice, PDEVICE_OBJECT TargetDevice);
// extern NTSTATUS (__stdcall *IoCreateDevice)(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, ULONG DeviceType, ULONG DeviceCharacteristics, BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject);
// extern void (__stdcall *IoDeleteDevice)(PDEVICE_OBJECT DeviceObject);
// extern void (__stdcall *IoDetachDevice)(PDEVICE_OBJECT TargetDevice);
// extern void (__stdcall *IoInitializeRemoveLockEx)(PIO_REMOVE_LOCK Lock, ULONG AllocateTag, ULONG MaxLockedMinutes, ULONG HighWatermark, ULONG RemlockSize);
// extern void (__stdcall *IoReleaseRemoveLockAndWaitEx)(PIO_REMOVE_LOCK RemoveLock, PVOID Tag, ULONG RemlockSize);
// extern NTSTATUS (__stdcall *IoCsqInitialize)(PIO_CSQ Csq, PIO_CSQ_INSERT_IRP CsqInsertIrp, PIO_CSQ_REMOVE_IRP CsqRemoveIrp, PIO_CSQ_PEEK_NEXT_IRP CsqPeekNextIrp, PIO_CSQ_ACQUIRE_LOCK CsqAcquireLock, PIO_CSQ_RELEASE_LOCK CsqReleaseLock, PIO_CSQ_COMPLETE_CANCELED_IRP CsqCompleteCanceledIrp);
// extern void (__stdcall *IoInvalidateDeviceRelations)(PDEVICE_OBJECT DeviceObject, DEVICE_RELATION_TYPE Type);
// extern NTSTATUS (__stdcall *IoRegisterDeviceInterface)(PDEVICE_OBJECT PhysicalDeviceObject, const GUID *InterfaceClassGuid, PUNICODE_STRING ReferenceString, PUNICODE_STRING SymbolicLinkName);
// extern NTSTATUS (__stdcall *IoSetDeviceInterfaceState)(PUNICODE_STRING SymbolicLinkName, BOOLEAN Enable);
// extern NTSTATUS (__stdcall *PoRequestPowerIrp)(PDEVICE_OBJECT DeviceObject, UCHAR MinorFunction, POWER_STATE PowerState, PREQUEST_POWER_COMPLETE CompletionFunction, PVOID Context, PIRP *Irp);
// extern POWER_STATE (__stdcall *PoSetPowerState)(PDEVICE_OBJECT DeviceObject, POWER_STATE_TYPE Type, POWER_STATE State);
// extern NTSTATUS (__stdcall *PoCallDriver)(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// extern void (__stdcall *PoStartNextPowerIrp)(PIRP Irp);
const GUID InterfaceClassGuid = { 3753827547u, 8520u, 16749u, { 158u, 77u, 206u, 204u, 36u, 36u, 18u, 140u } }; // idb
int dword_140004010 = 0; // weak
__int128 xmmword_140007430 = 0x76006500440042005500480047004Ci64; // weak
__int128 xmmword_140007440 = 0x5500480047004C005C006500630069i64; // weak
__int128 xmmword_140007450 = 0x69007400610070006D006F00430042i64; // weak
__int128 xmmword_140007460 = 0x7500740072006900560065006C0062i64; // weak
__int128 xmmword_140007470 = 0x6500630069007600650044006C0061i64; // weak
wchar_t aLogitech[10] = L"Logitech_"; // weak
wchar_t aLgvirhid[9] = L"LGVirHid"; // weak
const CHAR byte_1400074F0[2832] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb


//----- (00000001400014D0) ----------------------------------------------------
LONG __fastcall sub_1400014D0(__int64 a1)
{
  signed __int32 v2; // ebx
  LONG result; // eax

  v2 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 88));
  if ( v2 == 1 )
    result = KeSetEvent((PRKEVENT)(a1 + 120), 0, 0);
  if ( !v2 )
    return KeSetEvent((PRKEVENT)(a1 + 96), 0, 0);
  return result;
}

//----- (000000014000151C) ----------------------------------------------------
void __fastcall sub_14000151C(__int64 a1)
{
  if ( _InterlockedIncrement((volatile signed __int32 *)(a1 + 88)) == 2 )
    KeClearEvent((PRKEVENT)(a1 + 120));
}

//----- (0000000140001540) ----------------------------------------------------
NTSTATUS __fastcall sub_140001540(__int64 a1, IRP *a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a1 + 64);
  ++a2->CurrentLocation;
  ++a2->Tail.Overlay.CurrentStackLocation;
  return IofCallDriver(*(PDEVICE_OBJECT *)(v2 + 48), a2);
}

//----- (000000014000155C) ----------------------------------------------------
__int64 *__fastcall sub_14000155C(__int64 a1, int a2)
{
  __int64 *v4; // rbx
  KIRQL v5; // r8
  __int64 *i; // rax

  v4 = 0i64;
  v5 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(a1 + 80));
  if ( *(_DWORD *)(a1 + 72) )
  {
    for ( i = *(__int64 **)(a1 + 56); i != (__int64 *)(a1 + 56); i = (__int64 *)*i )
    {
      if ( a2 == *((_DWORD *)i - 2) && *((_BYTE *)i + 16) )
      {
        v4 = i - 33;
        break;
      }
    }
  }
  KeReleaseSpinLock((PKSPIN_LOCK)(a1 + 80), v5);
  return v4;
}

//----- (00000001400015D0) ----------------------------------------------------
void __fastcall CsqAcquireLock(PIO_CSQ Csq, PKIRQL Irql)
{
  *Irql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)&Csq[1].CsqRemoveIrp);
}

//----- (00000001400015EC) ----------------------------------------------------
void __fastcall CsqCompleteCanceledIrp(PIO_CSQ Csq, PIRP Irp)
{
  _InterlockedExchange64((volatile __int64 *)&Irp->Tail, 0i64);
  Irp->IoStatus.Information = 0i64;
  Irp->IoStatus.Status = -1073741536;
  IofCompleteRequest(Irp, 0);
  IoReleaseRemoveLockEx((PIO_REMOVE_LOCK)&Csq[-1].CsqAcquireLock, Irp, 0x20u);
}

//----- (0000000140001638) ----------------------------------------------------
void __fastcall CsqInsertIrp(struct _IO_CSQ *Csq, PIRP Irp)
{
  PIO_CSQ_INSERT_IRP v2; // rax
  struct _IO_CSQ *v3; // rcx
  struct _IRP::$::$2AD798E65616C4F7304824DBFA27E419::$665C8370128C04AB892B069E6FB086E8 *p_ListEntry; // rdx

  v2 = Csq[1].CsqInsertIrp;
  v3 = Csq + 1;
  p_ListEntry = (struct _IRP::$::$2AD798E65616C4F7304824DBFA27E419::$665C8370128C04AB892B069E6FB086E8 *)&Irp->Tail.Overlay.ListEntry;
  p_ListEntry->ListEntry.Blink = (struct _LIST_ENTRY *)v2;
  p_ListEntry->ListEntry.Flink = (struct _LIST_ENTRY *)v3;
  if ( *(struct _IO_CSQ **)v2 != v3 )
    __fastfail(3u);
  *(_QWORD *)v2 = p_ListEntry;
  v3->CsqInsertIrp = (PIO_CSQ_INSERT_IRP)p_ListEntry;
}

//----- (0000000140001664) ----------------------------------------------------
struct _LIST_ENTRY **__fastcall CsqPeekNextIrp(PIO_CSQ Csq, PIRP Irp, struct _LIST_ENTRY *PeekContext)
{
  struct _LIST_ENTRY **p_Blink; // r9
  struct _LIST_ENTRY **v4; // rcx
  struct _LIST_ENTRY *Flink; // rax

  p_Blink = 0i64;
  v4 = (struct _LIST_ENTRY **)&Csq[1];
  if ( Irp )
    Flink = Irp->Tail.Overlay.ListEntry.Flink;
  else
    Flink = *v4;
  while ( Flink != (struct _LIST_ENTRY *)v4 )
  {
    p_Blink = &Flink[-11].Blink;
    if ( !PeekContext || p_Blink[15] == PeekContext )
      break;
    Flink = Flink->Flink;
    p_Blink = 0i64;
  }
  return p_Blink;
}

//----- (00000001400016A0) ----------------------------------------------------
void __fastcall CsqReleaseLock(PIO_CSQ Csq, KIRQL Irql)
{
  KeReleaseSpinLock((PKSPIN_LOCK)&Csq[1].CsqRemoveIrp, Irql);
}

//----- (00000001400016AC) ----------------------------------------------------
void __fastcall CsqRemoveIrp(PIO_CSQ Csq, PIRP Irp)
{
  struct _IRP::$::$2AD798E65616C4F7304824DBFA27E419::$665C8370128C04AB892B069E6FB086E8 *p_ListEntry; // rdx
  struct _LIST_ENTRY *Flink; // rcx
  struct _LIST_ENTRY *Blink; // rax

  p_ListEntry = (struct _IRP::$::$2AD798E65616C4F7304824DBFA27E419::$665C8370128C04AB892B069E6FB086E8 *)&Irp->Tail.Overlay.ListEntry;
  Flink = p_ListEntry->ListEntry.Flink;
  Blink = p_ListEntry->ListEntry.Blink;
  if ( (struct _IRP::$::$2AD798E65616C4F7304824DBFA27E419::$665C8370128C04AB892B069E6FB086E8 *)p_ListEntry->ListEntry.Flink->Blink != p_ListEntry
    || (struct _IRP::$::$2AD798E65616C4F7304824DBFA27E419::$665C8370128C04AB892B069E6FB086E8 *)Blink->Flink != p_ListEntry )
  {
    __fastfail(3u);
  }
  Blink->Flink = Flink;
  Flink->Blink = Blink;
}

//----- (00000001400016D4) ----------------------------------------------------
__int64 __fastcall sub_1400016D4(__int64 a1, __int64 a2)
{
  __int64 v2; // r9

  v2 = *(_QWORD *)(a2 + 112);
  if ( *(_BYTE *)(v2 + 12) != 42 )
    return 3221225474i64;
  *(_DWORD *)(*(_QWORD *)v2 + 1i64) = *(_DWORD *)(a1 + 256);
  *(_QWORD *)(a2 + 56) = *(unsigned int *)(v2 + 8);
  return 0i64;
}

//----- (0000000140001700) ----------------------------------------------------
__int64 __fastcall sub_140001700(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  unsigned int v3; // edi
  __int64 v7; // rax
  _DWORD *v8; // rsi
  unsigned int v9; // ecx
  __int64 v10; // rbp
  unsigned int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  _DWORD *v16; // rcx
  __int64 *v17; // rax
  unsigned int v18; // ecx
  unsigned int v19; // ecx
  unsigned int v20; // ecx
  unsigned int v21; // ecx
  unsigned int v22; // ecx

  v2 = *(_QWORD *)(a1 + 64);
  v3 = 0;
  if ( *(_DWORD *)(v2 + 12) == 6 )
  {
    v3 = -1073741738;
    *(_DWORD *)(a2 + 48) = -1073741738;
LABEL_3:
    IofCompleteRequest((PIRP)a2, 0);
    return v3;
  }
  v7 = *(_QWORD *)(a2 + 184);
  v8 = *(_DWORD **)(a2 + 24);
  v9 = *(_DWORD *)(v7 + 24);
  v10 = *(unsigned int *)(v7 + 16);
  if ( v9 > 0x2A2023 )
  {
    v18 = v9 - 2760743;
    if ( v18 )
    {
      v19 = v18 - 1;
      if ( !v19 )
      {
        if ( v8 && *v8 == 12 && (unsigned int)v8[2] + 12i64 == v10 )
        {
          sub_140001E04(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 64i64), *(int **)(a2 + 24));
          *(_QWORD *)(a2 + 56) = 0i64;
        }
        else
        {
          v3 = -1073741811;
        }
        goto LABEL_36;
      }
      v20 = v19 - 7;
      if ( v20 )
      {
        v21 = v20 - 4;
        if ( v21 )
        {
          v22 = v21 - 4;
          if ( v22 )
          {
            if ( v22 != 4 )
            {
LABEL_26:
              v3 = -1073741637;
              goto LABEL_36;
            }
            return sub_1400024E0(a1, (IRP *)a2);
          }
          else
          {
            return sub_140002440(a1, (IRP *)a2);
          }
        }
        else
        {
          return sub_140002484(a1, (IRP *)a2);
        }
      }
      else
      {
        return sub_1400023C0(a1, (IRP *)a2);
      }
    }
    else
    {
      return sub_140002524(a1, (IRP *)a2);
    }
  }
  else
  {
    if ( v9 != 2760739 )
    {
      v11 = v9 - 721320;
      if ( !v11 )
        goto LABEL_36;
      v12 = v11 - 2039396;
      if ( v12 )
      {
        v13 = v12 - 4;
        if ( v13 )
        {
          v14 = v13 - 4;
          if ( v14 )
          {
            v15 = v14 - 4;
            if ( v15 )
            {
              if ( v15 != 4 )
                goto LABEL_26;
            }
            else
            {
              memmove(*(void **)(a2 + 112), *(const void **)(v2 + 96), *(unsigned int *)(v2 + 88));
            }
          }
          else
          {
            v16 = *(_DWORD **)(a2 + 112);
            *v16 = *(unsigned __int16 *)(v2 + 50);
            v16[1] = *(unsigned __int16 *)(v2 + 48);
            v16[2] = *(unsigned __int16 *)(v2 + 52);
            v16[3] = *(_DWORD *)(v2 + 88);
          }
LABEL_36:
          *(_DWORD *)(a2 + 48) = v3;
          goto LABEL_3;
        }
        v17 = sub_14000155C(
                *(_QWORD *)(*(_QWORD *)(v2 + 32) + 64i64),
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 64i64) + 168i64));
        if ( !v17 )
          goto LABEL_36;
      }
      else
      {
        v17 = sub_14000155C(
                *(_QWORD *)(*(_QWORD *)(v2 + 32) + 64i64),
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 64i64) + 164i64));
        if ( !v17 )
          goto LABEL_36;
      }
      sub_140001D1C(*v17, v8, v10);
      goto LABEL_36;
    }
    return sub_140001A24(v2, a2);
  }
}

//----- (00000001400018EC) ----------------------------------------------------
void __fastcall sub_1400018EC(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  IRP *v4; // rbx
  _QWORD *i; // rax
  _QWORD *v6; // rdx
  _QWORD *v7; // rcx

  v2 = *(_QWORD *)(a1 + 64);
  v4 = 0i64;
  KeAcquireSpinLockAtDpcLevel((PKSPIN_LOCK)(v2 + 104));
  IoReleaseCancelSpinLock(KeGetCurrentIrql());
  for ( i = *(_QWORD **)(v2 + 112); i != (_QWORD *)(v2 + 112); i = (_QWORD *)*i )
  {
    if ( i - 21 == (_QWORD *)a2 )
    {
      v6 = (_QWORD *)*i;
      v7 = (_QWORD *)i[1];
      if ( *(_QWORD **)(*i + 8i64) != i || (_QWORD *)*v7 != i )
        __fastfail(3u);
      *v7 = v6;
      v4 = (IRP *)(i - 21);
      v6[1] = v7;
      break;
    }
  }
  KeReleaseSpinLock((PKSPIN_LOCK)(v2 + 104), *(_BYTE *)(a2 + 69));
  if ( v4 )
  {
    v4->IoStatus.Information = 0i64;
    v4->IoStatus.Status = -1073741536;
    IofCompleteRequest(v4, 0);
    IoReleaseRemoveLockEx((PIO_REMOVE_LOCK)(v2 + 128), v4, 0x20u);
  }
}

//----- (00000001400019B4) ----------------------------------------------------
__int64 *__fastcall sub_1400019B4(__int64 a1)
{
  __int64 v1; // rbx
  __int64 *v2; // rdi
  KSPIN_LOCK *v3; // rsi
  KIRQL v4; // al
  __int64 **v5; // rbx
  KIRQL v6; // dl
  __int64 *v7; // rax
  __int64 v8; // rcx

  v1 = *(_QWORD *)(a1 + 64);
  v2 = 0i64;
  v3 = (KSPIN_LOCK *)(v1 + 104);
  v4 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v1 + 104));
  v5 = (__int64 **)(v1 + 112);
  v6 = v4;
  if ( *v5 != (__int64 *)v5 )
  {
    v7 = *v5;
    v8 = **v5;
    if ( (__int64 **)(*v5)[1] != v5 || *(__int64 **)(v8 + 8) != v7 )
      __fastfail(3u);
    *v5 = (__int64 *)v8;
    v2 = v7 - 21;
    *(_QWORD *)(v8 + 8) = v5;
  }
  KeReleaseSpinLock(v3, v6);
  return v2;
}

//----- (0000000140001A24) ----------------------------------------------------
__int64 __fastcall sub_140001A24(__int64 a1, __int64 a2)
{
  KSPIN_LOCK *v2; // rsi
  KIRQL v5; // al
  KIRQL v6; // r9
  unsigned int v7; // edi
  __int64 v8; // rax
  __int64 v9; // rcx
  _QWORD *v10; // rdx

  v2 = (KSPIN_LOCK *)(a1 + 104);
  v5 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(a1 + 104));
  _InterlockedExchange64((volatile __int64 *)(a2 + 104), (__int64)sub_1400018EC);
  v6 = v5;
  if ( *(_BYTE *)(a2 + 68) && _InterlockedExchange64((volatile __int64 *)(a2 + 104), 0i64) )
  {
    KeReleaseSpinLock(v2, v5);
    v7 = -1073741536;
    *(_DWORD *)(a2 + 48) = -1073741536;
    IofCompleteRequest((PIRP)a2, 0);
  }
  else
  {
    v8 = *(_QWORD *)(a2 + 184);
    v9 = a2 + 168;
    v7 = 259;
    *(_DWORD *)(a2 + 48) = 259;
    *(_BYTE *)(v8 + 3) |= 1u;
    v10 = *(_QWORD **)(a1 + 120);
    *(_QWORD *)(a2 + 168) = a1 + 112;
    *(_QWORD *)(a2 + 176) = v10;
    if ( *v10 != a1 + 112 )
      __fastfail(3u);
    *v10 = v9;
    *(_QWORD *)(a1 + 120) = v9;
    KeReleaseSpinLock(v2, v6);
    IoAcquireRemoveLockEx((PIO_REMOVE_LOCK)(a1 + 128), (PVOID)a2, File, 1u, 0x20u);
  }
  return v7;
}

//----- (0000000140001B10) ----------------------------------------------------
PIRP __fastcall sub_140001B10(__int64 a1)
{
  __int64 v1; // rsi
  KIRQL v2; // al
  __int64 **v3; // rbx
  __int64 *v4; // rdi
  __int64 v5; // rcx
  __int64 *v6; // rdi
  PIRP result; // rax
  PIRP v8; // rbx

  v1 = *(_QWORD *)(a1 + 64);
  v2 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v1 + 104));
  v3 = (__int64 **)(v1 + 112);
  while ( *v3 != (__int64 *)v3 )
  {
    v4 = *v3;
    v5 = **v3;
    if ( (__int64 **)(*v3)[1] != v3 || *(__int64 **)(v5 + 8) != v4 )
      __fastfail(3u);
    *v3 = (__int64 *)v5;
    v6 = v4 - 21;
    *(_QWORD *)(v5 + 8) = v3;
    if ( *((_BYTE *)v6 + 68) && _InterlockedExchange64(v6 + 13, 0i64) )
    {
      KeReleaseSpinLock((PKSPIN_LOCK)(v1 + 104), v2);
      v6[7] = 0i64;
      *((_DWORD *)v6 + 12) = -1073741536;
    }
    else
    {
      v6[7] = 0i64;
      *((_DWORD *)v6 + 12) = -1073741738;
      KeReleaseSpinLock((PKSPIN_LOCK)(v1 + 104), v2);
    }
    IofCompleteRequest((PIRP)v6, 0);
    IoReleaseRemoveLockEx((PIO_REMOVE_LOCK)(v1 + 128), v6, 0x20u);
    v2 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v1 + 104));
  }
  KeReleaseSpinLock((PKSPIN_LOCK)(v1 + 104), v2);
  while ( 1 )
  {
    result = IoCsqRemoveNextIrp((PIO_CSQ)(v1 + 160), 0i64);
    v8 = result;
    if ( !result )
      break;
    result->Tail.Overlay.DeviceQueueEntry.DeviceListEntry.Flink = 0i64;
    result->IoStatus.Information = 0i64;
    result->IoStatus.Status = -1073741738;
    IofCompleteRequest(result, 0);
    IoReleaseRemoveLockEx((PIO_REMOVE_LOCK)(v1 + 128), v8, 0x20u);
  }
  return result;
}

//----- (0000000140001C4C) ----------------------------------------------------
void __fastcall sub_140001C4C(__int64 a1, const void *a2, unsigned int a3)
{
  __int64 v3; // rbx
  __int64 *v6; // rax
  IRP *v7; // rbp
  IRP *v8; // rcx
  void *v9; // rsi
  size_t v10; // rbx

  v3 = *(_QWORD *)(a1 + 64);
  v6 = sub_1400019B4(a1);
  v7 = (IRP *)v6;
  if ( v6 )
  {
    if ( *((_BYTE *)v6 + 68) && _InterlockedExchange64(v6 + 13, 0i64) )
    {
      v6[7] = 0i64;
      *((_DWORD *)v6 + 12) = -1073741536;
      v8 = (IRP *)v6;
    }
    else
    {
      _InterlockedExchange64(v6 + 13, 0i64);
      if ( *(_DWORD *)(v3 + 12) == 4 )
      {
        v6[7] = 0i64;
        *((_DWORD *)v6 + 12) = -1073741738;
        v8 = (IRP *)v6;
      }
      else
      {
        v9 = (void *)v6[14];
        v10 = *(unsigned int *)(v6[23] + 8);
        memset(v9, 0, v10);
        if ( (unsigned int)v10 < a3 )
          a3 = v10;
        memmove(v9, a2, a3);
        v7->IoStatus.Status = 0;
        v7->IoStatus.Information = v10;
        v8 = v7;
      }
    }
    IofCompleteRequest(v8, 0);
  }
}

//----- (0000000140001D1C) ----------------------------------------------------
void __fastcall sub_140001D1C(__int64 a1, const void *a2, unsigned int a3)
{
  struct _IO_REMOVE_LOCK *v3; // r15
  __int64 *v6; // rax
  int v7; // r14d
  IRP *v8; // rbp
  void *v9; // rsi
  size_t v10; // rbx

  v3 = *(struct _IO_REMOVE_LOCK **)(a1 + 64);
  v6 = sub_1400019B4(a1);
  v7 = 0;
  v8 = (IRP *)v6;
  if ( v6 )
  {
    if ( *((_BYTE *)v6 + 68) && _InterlockedExchange64(v6 + 13, 0i64) )
    {
      v6[7] = 0i64;
      v7 = -1073741536;
    }
    else
    {
      _InterlockedExchange64(v6 + 13, 0i64);
      if ( v3->Common.RemoveEvent.Header.SignalState == 4 )
      {
        v6[7] = 0i64;
        v7 = -1073741738;
      }
      else
      {
        v9 = (void *)v6[14];
        v10 = *(unsigned int *)(v6[23] + 8);
        memset(v9, 0, v10);
        if ( (unsigned int)v10 < a3 )
          a3 = v10;
        memmove(v9, a2, a3);
        v8->IoStatus.Information = v10;
      }
    }
    v8->IoStatus.Status = v7;
    IofCompleteRequest(v8, 0);
    IoReleaseRemoveLockEx(v3 + 4, v8, 0x20u);
  }
}

//----- (0000000140001E04) ----------------------------------------------------
void __fastcall sub_140001E04(__int64 a1, int *a2)
{
  __int64 *v3; // rax
  int v4; // ebp
  struct _IO_REMOVE_LOCK *v5; // r15
  __int64 *v6; // rax
  IRP *v7; // r14
  void *v8; // rsi
  size_t v9; // rbx
  unsigned int v10; // eax

  v3 = sub_14000155C(a1, a2[1]);
  v4 = 0;
  v5 = (struct _IO_REMOVE_LOCK *)v3;
  if ( v3 )
  {
    if ( *v3 )
    {
      v6 = sub_1400019B4(*v3);
      v7 = (IRP *)v6;
      if ( v6 )
      {
        if ( *((_BYTE *)v6 + 68) && _InterlockedExchange64(v6 + 13, 0i64) )
        {
          v6[7] = 0i64;
          v4 = -1073741536;
        }
        else
        {
          _InterlockedExchange64(v6 + 13, 0i64);
          if ( v5->Common.RemoveEvent.Header.SignalState == 4 )
          {
            v6[7] = 0i64;
            v4 = -1073741738;
          }
          else
          {
            v8 = (void *)v6[14];
            v9 = *(unsigned int *)(v6[23] + 8);
            memset(v8, 0, v9);
            v10 = a2[2];
            if ( (unsigned int)v9 < v10 )
              v10 = v9;
            a2[2] = v10;
            memmove(v8, a2 + 3, v10);
            v7->IoStatus.Information = v9;
          }
        }
        v7->IoStatus.Status = v4;
        IofCompleteRequest(v7, 0);
        IoReleaseRemoveLockEx(v5 + 4, v7, 0x20u);
      }
    }
  }
}

//----- (0000000140001F0C) ----------------------------------------------------
__int64 __fastcall sub_140001F0C(__int64 a1, IRP *a2, DWORD a3)
{
  struct _FILE_OBJECT *v3; // rbp
  struct _DEVICE_OBJECT *v4; // r13
  const void **UserBuffer; // r12
  struct _IO_REMOVE_LOCK *v6; // rsi
  NTSTATUS v9; // eax
  unsigned int v10; // edi
  PIRP Irp; // rdi
  ULONG v13; // r15d
  struct _IRP *PoolWithTag; // rax
  struct _IRP *v15; // rbp
  struct _MDL *Mdl; // rax
  struct _MDL *v17; // r15
  PIO_CSQ *v18; // rax
  signed __int32 *v19; // rdx
  signed __int32 v20; // eax
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rax
  struct _IO_STACK_LOCATION *v22; // rax
  PIO_CSQ *v23; // [rsp+30h] [rbp-58h]
  ULONG v24; // [rsp+90h] [rbp+8h]
  size_t MaxCount; // [rsp+98h] [rbp+10h]
  struct _FILE_OBJECT *v27; // [rsp+A8h] [rbp+20h]

  v3 = *(struct _FILE_OBJECT **)(a1 + 80);
  v4 = *(struct _DEVICE_OBJECT **)(a1 + 64);
  UserBuffer = (const void **)a2->UserBuffer;
  v6 = (struct _IO_REMOVE_LOCK *)(a1 + 128);
  v27 = v3;
  v9 = IoAcquireRemoveLockEx((PIO_REMOVE_LOCK)(a1 + 128), a2, File, 1u, 0x20u);
  v10 = v9;
  if ( v9 < 0 )
  {
    a2->IoStatus.Information = 0i64;
    a2->IoStatus.Status = v9;
    IofCompleteRequest(a2, 0);
    return v10;
  }
  if ( v4 && v3 )
  {
    if ( !UserBuffer || (Irp = IoAllocateIrp(v4->StackSize + 4, 0)) == 0i64 )
    {
      v10 = -1073741670;
      a2->IoStatus.Status = -1073741670;
      IofCompleteRequest(a2, 0);
LABEL_8:
      IoReleaseRemoveLockEx(v6, a2, 0x20u);
      return v10;
    }
    v13 = *((_DWORD *)UserBuffer + 2);
    v24 = v13;
    MaxCount = v13;
    PoolWithTag = (struct _IRP *)ExAllocatePoolWithTag((POOL_TYPE)512, v13, 0x68707276u);
    v15 = PoolWithTag;
    if ( !PoolWithTag )
    {
LABEL_11:
      IoFreeIrp(Irp);
      v10 = -1073741670;
      a2->IoStatus.Status = -1073741670;
      IofCompleteRequest(a2, 0);
      goto LABEL_8;
    }
    Mdl = IoAllocateMdl(PoolWithTag, v13, 0, 0, Irp);
    v17 = Mdl;
    if ( !Mdl )
    {
LABEL_13:
      ExFreePoolWithTag(v15, 0x68707276u);
      goto LABEL_11;
    }
    MmBuildMdlForNonPagedPool(Mdl);
    v18 = (PIO_CSQ *)ExAllocatePoolWithTag((POOL_TYPE)512, 0x28ui64, 0x78637478u);
    v19 = (signed __int32 *)v18;
    v23 = v18;
    if ( !v18 )
    {
      IoFreeMdl(v17);
      goto LABEL_13;
    }
    v18[1] = (PIO_CSQ)a1;
    v18[2] = (PIO_CSQ)(a1 + 160);
    v20 = _InterlockedIncrement((volatile signed __int32 *)(a1 + 248));
    *((_QWORD *)v19 + 3) = UserBuffer;
    *v19 = v20;
    *((_QWORD *)v19 + 4) = v15;
    memmove(v15, *UserBuffer, MaxCount);
    CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
    CurrentStackLocation[-1].Parameters.CreatePipe.Parameters = 0i64;
    CurrentStackLocation[-1].Parameters.Read.ByteOffset.LowPart = a3;
    CurrentStackLocation[-1].Parameters.Create.Options = v24;
    CurrentStackLocation[-1].Parameters.Read.Length = v24;
    CurrentStackLocation[-1].FileObject = v27;
    CurrentStackLocation[-1].MajorFunction = 14;
    v22 = Irp->Tail.Overlay.CurrentStackLocation;
    Irp->AssociatedIrp.MasterIrp = v15;
    Irp->UserBuffer = v15;
    v22[-1].Control = -32;
    v22[-1].CompletionRoutine = (PIO_COMPLETION_ROUTINE)sub_14000259C;
    v22[-1].Context = v23;
    Irp->IoStatus.Status = -1073741637;
    a2->Tail.Overlay.DeviceQueueEntry.DeviceListEntry.Flink = (struct _LIST_ENTRY *)*(int *)v23;
    IoCsqInsertIrp(v23[2], a2, 0i64);
    IofCallDriver(v4, Irp);
    return 259i64;
  }
  else
  {
    a2->IoStatus.Status = 0;
    IofCompleteRequest(a2, 0);
    IoReleaseRemoveLockEx(v6, a2, 0x20u);
    return 0i64;
  }
}

//----- (0000000140002188) ----------------------------------------------------
__int64 __fastcall sub_140002188(__int64 a1, IRP *a2)
{
  struct _DEVICE_OBJECT *v2; // r15
  const void **UserBuffer; // r12
  NTSTATUS v6; // eax
  unsigned int v7; // edi
  unsigned int v8; // ebx
  PIRP Irp; // rbp
  ULONG v11; // ebx
  PVOID PoolWithTag; // rax
  void *v13; // r14
  struct _MDL *Mdl; // rax
  struct _MDL *v15; // rbx
  int *v16; // rcx
  signed __int32 v17; // eax
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rax
  struct _IRP *MasterIrp; // rax
  struct _IO_STACK_LOCATION *v20; // rax
  int *v21; // [rsp+30h] [rbp-48h]
  ULONG v22; // [rsp+80h] [rbp+8h]
  struct _IO_REMOVE_LOCK *RemoveLock; // [rsp+88h] [rbp+10h]
  size_t MaxCount; // [rsp+98h] [rbp+20h]

  v2 = *(struct _DEVICE_OBJECT **)(a1 + 64);
  UserBuffer = (const void **)a2->UserBuffer;
  RemoveLock = (struct _IO_REMOVE_LOCK *)(a1 + 128);
  v6 = IoAcquireRemoveLockEx((PIO_REMOVE_LOCK)(a1 + 128), a2, File, 1u, 0x20u);
  v7 = 0;
  v8 = v6;
  if ( v6 < 0 )
  {
    a2->IoStatus.Information = 0i64;
    a2->IoStatus.Status = v6;
    IofCompleteRequest(a2, 0);
    return v8;
  }
  if ( !v2 )
  {
    a2->IoStatus.Status = 0;
LABEL_14:
    IofCompleteRequest(a2, 0);
    IoReleaseRemoveLockEx(RemoveLock, a2, 0x20u);
    return v7;
  }
  if ( !UserBuffer || (Irp = IoAllocateIrp(v2->StackSize + 4, 0)) == 0i64 )
  {
LABEL_13:
    a2->IoStatus.Status = -1073741670;
    v7 = -1073741670;
    goto LABEL_14;
  }
  v11 = *((_DWORD *)UserBuffer + 2);
  v22 = v11;
  MaxCount = v11;
  PoolWithTag = ExAllocatePoolWithTag((POOL_TYPE)512, v11, 0x68707276u);
  v13 = PoolWithTag;
  if ( !PoolWithTag )
  {
LABEL_12:
    IoFreeIrp(Irp);
    goto LABEL_13;
  }
  Mdl = IoAllocateMdl(PoolWithTag, v11, 0, 0, Irp);
  v15 = Mdl;
  if ( !Mdl )
  {
LABEL_11:
    ExFreePoolWithTag(v13, 0x68707276u);
    goto LABEL_12;
  }
  MmBuildMdlForNonPagedPool(Mdl);
  v16 = (int *)ExAllocatePoolWithTag((POOL_TYPE)512, 0x28ui64, 0x78637478u);
  v21 = v16;
  if ( !v16 )
  {
    IoFreeMdl(v15);
    goto LABEL_11;
  }
  v17 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 248), 1u);
  *((_QWORD *)v16 + 1) = a1;
  *((_QWORD *)v16 + 3) = UserBuffer;
  *((_QWORD *)v16 + 4) = v13;
  *((_QWORD *)v16 + 2) = a1 + 160;
  *v16 = v17 + 1;
  memmove(v13, *UserBuffer, MaxCount);
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  CurrentStackLocation[-1].Parameters.Read.Length = v22;
  CurrentStackLocation[-1].MajorFunction = 4;
  CurrentStackLocation[-1].Parameters.Create.Options = 0;
  CurrentStackLocation[-1].Parameters.Read.ByteOffset.QuadPart = 0i64;
  MasterIrp = a2->AssociatedIrp.MasterIrp;
  Irp->UserBuffer = v13;
  Irp->AssociatedIrp.MasterIrp = MasterIrp;
  v20 = Irp->Tail.Overlay.CurrentStackLocation;
  v20[-1].CompletionRoutine = (PIO_COMPLETION_ROUTINE)sub_1400026B8;
  v20[-1].Control = -32;
  v20[-1].Context = v21;
  Irp->IoStatus.Status = -1073741637;
  a2->Tail.Overlay.DeviceQueueEntry.DeviceListEntry.Flink = (struct _LIST_ENTRY *)*v21;
  IoCsqInsertIrp((PIO_CSQ)(a1 + 160), a2, 0i64);
  IofCallDriver(v2, Irp);
  return 259i64;
}

//----- (00000001400023C0) ----------------------------------------------------
__int64 __fastcall sub_1400023C0(__int64 a1, IRP *a2)
{
  __int64 v2; // rdi
  int v5; // eax

  v2 = *(_QWORD *)(a1 + 64);
  a2->IoStatus.Information = a2->MdlAddress->ByteCount;
  if ( v2 && (v5 = *(_DWORD *)(v2 + 56)) != 0 )
  {
    if ( v5 == 2 && (unsigned int)sub_1400016D4(v2, (__int64)a2) )
    {
      return sub_140001F0C(v2, a2, 0xB0192u);
    }
    else
    {
      a2->IoStatus.Status = 0;
      IofCompleteRequest(a2, 0);
      return 0i64;
    }
  }
  else
  {
    a2->IoStatus.Status = -1073741637;
    IofCompleteRequest(a2, 0);
    return 3221225659i64;
  }
}

//----- (0000000140002440) ----------------------------------------------------
__int64 __fastcall sub_140002440(__int64 a1, IRP *a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a1 + 64);
  if ( v2 && *(_DWORD *)(v2 + 56) == 2 )
    return sub_140001F0C(v2, a2, 0xB01A2u);
  a2->IoStatus.Status = -1073741637;
  IofCompleteRequest(a2, 0);
  return 3221225659i64;
}

//----- (0000000140002484) ----------------------------------------------------
__int64 __fastcall sub_140002484(__int64 a1, IRP *a2)
{
  __int64 v2; // rcx
  int v4; // eax

  v2 = *(_QWORD *)(a1 + 64);
  if ( v2 && (v4 = *(_DWORD *)(v2 + 56)) != 0 )
  {
    if ( v4 == 2 )
    {
      return sub_140001F0C(v2, a2, 0xB0191u);
    }
    else
    {
      a2->IoStatus.Status = 0;
      IofCompleteRequest(a2, 0);
      return 0i64;
    }
  }
  else
  {
    a2->IoStatus.Status = -1073741637;
    IofCompleteRequest(a2, 0);
    return 3221225659i64;
  }
}

//----- (00000001400024E0) ----------------------------------------------------
__int64 __fastcall sub_1400024E0(__int64 a1, IRP *a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(a1 + 64);
  if ( v2 && *(_DWORD *)(v2 + 56) == 2 )
    return sub_140001F0C(v2, a2, 0xB0195u);
  a2->IoStatus.Status = -1073741637;
  IofCompleteRequest(a2, 0);
  return 3221225659i64;
}

//----- (0000000140002524) ----------------------------------------------------
__int64 __fastcall sub_140002524(__int64 a1, IRP *a2)
{
  __int64 v2; // r10
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 64);
  a2->IoStatus.Information = a2->MdlAddress->ByteCount;
  if ( v2 )
  {
    if ( *(_DWORD *)(v2 + 56) == 2 )
    {
      result = sub_140002188(v2, a2);
      if ( (_DWORD)result == 259 )
      {
        return 259i64;
      }
      else if ( (_DWORD)result == -1073741536 )
      {
        return 3221225760i64;
      }
    }
    else
    {
      a2->IoStatus.Status = 0;
      IofCompleteRequest(a2, 0);
      return 0i64;
    }
  }
  else
  {
    a2->IoStatus.Status = -1073741637;
    IofCompleteRequest(a2, 0);
    return 3221225659i64;
  }
  return result;
}

//----- (000000014000259C) ----------------------------------------------------
__int64 __fastcall sub_14000259C(__int64 a1, IRP *a2, __int64 a3)
{
  struct _IO_REMOVE_LOCK *v3; // rbp
  __int32 v5; // eax
  PIRP v7; // rax
  IRP *v8; // rsi
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  __int64 v10; // rax
  ULONG_PTR v11; // rcx
  struct _MDL *MdlAddress; // rcx
  void *v13; // rcx

  v3 = *(struct _IO_REMOVE_LOCK **)(a3 + 8);
  v5 = _InterlockedExchange((volatile __int32 *)a3, 0);
  if ( v5 )
  {
    v7 = IoCsqRemoveNextIrp(*(PIO_CSQ *)(a3 + 16), (PVOID)v5);
    v8 = v7;
    if ( v7 )
    {
      _InterlockedExchange64((volatile __int64 *)&v7->Tail, 0i64);
      v7->IoStatus.Status = a2->IoStatus.Status;
      CurrentStackLocation = v7->Tail.Overlay.CurrentStackLocation;
      v7->IoStatus.Information = a2->IoStatus.Information;
      if ( CurrentStackLocation->Parameters.Read.ByteOffset.LowPart == 2760751
        || CurrentStackLocation->Parameters.Read.ByteOffset.LowPart == 2760759 )
      {
        if ( *(_QWORD *)(a3 + 32) )
        {
          v10 = *(_QWORD *)(a3 + 24);
          if ( v10 )
          {
            if ( *(_QWORD *)v10 )
            {
              v11 = *(unsigned int *)(v10 + 8);
              if ( v11 < a2->IoStatus.Information )
                a2->IoStatus.Information = v11;
              memmove(**(void ***)(a3 + 24), *(const void **)(a3 + 32), a2->IoStatus.Information);
            }
          }
        }
      }
      IofCompleteRequest(v8, 0);
      IoReleaseRemoveLockEx(v3 + 4, v8, 0x20u);
    }
  }
  MdlAddress = a2->MdlAddress;
  if ( MdlAddress )
    IoFreeMdl(MdlAddress);
  v13 = *(void **)(a3 + 32);
  if ( v13 )
    ExFreePoolWithTag(v13, 0x68707276u);
  ExFreePoolWithTag((PVOID)a3, 0x78637478u);
  IoFreeIrp(a2);
  return 3221225494i64;
}

//----- (00000001400026B8) ----------------------------------------------------
__int64 __fastcall sub_1400026B8(__int64 a1, IRP *a2, __int64 a3)
{
  struct _IO_REMOVE_LOCK *v3; // rbp
  __int32 v5; // eax
  PIRP v7; // rax
  PIRP v8; // rdi
  struct _MDL *MdlAddress; // rcx
  void *v10; // rcx

  v3 = *(struct _IO_REMOVE_LOCK **)(a3 + 8);
  v5 = _InterlockedExchange((volatile __int32 *)a3, 0);
  if ( v5 )
  {
    v7 = IoCsqRemoveNextIrp(*(PIO_CSQ *)(a3 + 16), (PVOID)v5);
    v8 = v7;
    if ( v7 )
    {
      _InterlockedExchange64((volatile __int64 *)&v7->Tail, 0i64);
      v7->IoStatus.Status = a2->IoStatus.Status;
      v7->IoStatus.Information = a2->IoStatus.Information;
      IofCompleteRequest(v7, 0);
      IoReleaseRemoveLockEx(v3 + 4, v8, 0x20u);
    }
  }
  MdlAddress = a2->MdlAddress;
  if ( MdlAddress )
    IoFreeMdl(MdlAddress);
  v10 = *(void **)(a3 + 32);
  if ( v10 )
    ExFreePoolWithTag(v10, 0x68707276u);
  ExFreePoolWithTag((PVOID)a3, 0x78637478u);
  IoFreeIrp(a2);
  return 3221225494i64;
}

//----- (0000000140002780) ----------------------------------------------------
__int64 __fastcall sub_140002780(__int64 a1, __int64 a2, struct _KEVENT *a3)
{
  if ( *(_BYTE *)(a2 + 65) )
    *(_BYTE *)(*(_QWORD *)(a2 + 184) + 3i64) |= 1u;
  KeSetEvent(a3, 0, 0);
  return 3221225494i64;
}

//----- (00000001400027B0) ----------------------------------------------------
NTSTATUS __fastcall sub_1400027B0(__int64 a1)
{
  NTSTATUS result; // eax

  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 72) = a1 + 64;
  *(_QWORD *)(a1 + 64) = a1 + 64;
  result = IoCsqInitialize(
             (PIO_CSQ)a1,
             (PIO_CSQ_INSERT_IRP)CsqInsertIrp,
             (PIO_CSQ_REMOVE_IRP)CsqRemoveIrp,
             (PIO_CSQ_PEEK_NEXT_IRP)CsqPeekNextIrp,
             (PIO_CSQ_ACQUIRE_LOCK)CsqAcquireLock,
             (PIO_CSQ_RELEASE_LOCK)CsqReleaseLock,
             (PIO_CSQ_COMPLETE_CANCELED_IRP)CsqCompleteCanceledIrp);
  *(_DWORD *)(a1 + 88) = 0;
  return result;
}

//----- (0000000140002814) ----------------------------------------------------
void __fastcall sub_140002814(__int64 a1, __int64 a2)
{
  KIRQL v4; // al
  _QWORD *v5; // rbx
  _QWORD *v6; // rdx

  v4 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(a1 + 80));
  v5 = (_QWORD *)(a2 + 264);
  v6 = *(_QWORD **)(a1 + 64);
  *v5 = a1 + 56;
  v5[1] = v6;
  if ( *v6 != a1 + 56 )
    __fastfail(3u);
  *v6 = v5;
  *(_QWORD *)(a1 + 64) = v5;
  ++*(_DWORD *)(a1 + 72);
  KeReleaseSpinLock((PKSPIN_LOCK)(a1 + 80), v4);
}

//----- (000000014000287C) ----------------------------------------------------
__int64 __fastcall sub_14000287C(__int64 a1, IRP *a2)
{
  KSPIN_LOCK *v2; // rbp
  KIRQL v5; // al
  int *Information; // r15
  KIRQL v7; // r14
  int v8; // esi
  _DWORD *PoolWithTag; // rax
  _DWORD *v10; // r12
  unsigned int v11; // ebx
  __int64 *v12; // r14
  _QWORD *v13; // rsi
  KIRQL NewIrql; // [rsp+50h] [rbp+8h]

  v2 = (KSPIN_LOCK *)(a1 + 80);
  v5 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(a1 + 80));
  Information = (int *)a2->IoStatus.Information;
  v7 = v5;
  NewIrql = v5;
  if ( Information )
  {
    v8 = *Information;
    if ( !*(_DWORD *)(a1 + 72) )
    {
      KeReleaseSpinLock(v2, v5);
LABEL_17:
      ++a2->CurrentLocation;
      ++a2->Tail.Overlay.CurrentStackLocation;
      v11 = IofCallDriver(*(PDEVICE_OBJECT *)(a1 + 48), a2);
      goto LABEL_18;
    }
  }
  else
  {
    v8 = 0;
  }
  PoolWithTag = ExAllocatePoolWithTag(
                  (POOL_TYPE)512,
                  8i64 * (unsigned int)(v8 + *(_DWORD *)(a1 + 72)) + 15,
                  0x65626D77u);
  v10 = PoolWithTag;
  if ( PoolWithTag )
  {
    if ( v8 )
      memmove(PoolWithTag + 2, Information + 2, 8i64 * v8);
    *v10 = v8 + *(_DWORD *)(a1 + 72);
    v12 = *(__int64 **)(a1 + 56);
    if ( v12 != (__int64 *)(a1 + 56) )
    {
      v13 = &v10[2 * v8 + 2];
      do
      {
        if ( *((_BYTE *)v12 + 16) )
        {
          *v13 = *(v12 - 33);
          ObfReferenceObject((PVOID)*(v12 - 33));
          ++v13;
        }
        *((_BYTE *)v12 + 17) = 1;
        v12 = (__int64 *)*v12;
      }
      while ( v12 != (__int64 *)(a1 + 56) );
    }
    KeReleaseSpinLock(v2, NewIrql);
    if ( Information )
      ExFreePool(Information);
    a2->IoStatus.Status = 0;
    a2->IoStatus.Information = (ULONG_PTR)v10;
    goto LABEL_17;
  }
  KeReleaseSpinLock(v2, v7);
  a2->IoStatus.Status = -1073741670;
  IofCompleteRequest(a2, 0);
  v11 = -1073741670;
LABEL_18:
  sub_1400014D0(a1);
  return v11;
}

//----- (00000001400029F0) ----------------------------------------------------
__int64 __fastcall sub_1400029F0(__int64 a1, __int64 a2)
{
  int v2; // edi
  KSPIN_LOCK *v3; // rbp
  char v6; // r15
  KIRQL v7; // al
  KIRQL v8; // r14
  int v10; // eax
  __int64 *v11; // rdi
  int v12; // eax
  void *v13; // rcx
  void *v14; // rcx
  void *v15; // rcx

  v2 = *(_DWORD *)(a1 + 8);
  v3 = (KSPIN_LOCK *)(a2 + 80);
  v6 = 0;
  v7 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(a2 + 80));
  v8 = v7;
  if ( !*(_DWORD *)(a2 + 72) )
  {
    KeReleaseSpinLock(v3, v7);
    return 3221225486i64;
  }
  switch ( v2 )
  {
    case 0:
      v10 = *(_DWORD *)(a2 + 164);
LABEL_9:
      *(_DWORD *)(a1 + 4) = v10;
      break;
    case 1:
      v10 = *(_DWORD *)(a2 + 168);
      goto LABEL_9;
    case 2:
      v10 = *(_DWORD *)(a2 + 172);
      goto LABEL_9;
  }
  v11 = *(__int64 **)(a2 + 56);
  if ( v11 != (__int64 *)(a2 + 56) )
  {
    while ( *(_DWORD *)(a1 + 4) != *((_DWORD *)v11 - 2) || !*((_BYTE *)v11 + 16) )
    {
      v11 = (__int64 *)*v11;
      if ( v11 == (__int64 *)(a2 + 56) )
        goto LABEL_28;
    }
    v12 = *((_DWORD *)v11 - 2);
    v6 = 1;
    if ( v12 == *(_DWORD *)(a2 + 164) )
    {
      *(_DWORD *)(a2 + 164) = 0;
    }
    else if ( v12 == *(_DWORD *)(a2 + 168) )
    {
      *(_DWORD *)(a2 + 168) = 0;
    }
    else if ( v12 == *(_DWORD *)(a2 + 172) )
    {
      *(_DWORD *)(a2 + 172) = 0;
    }
    v13 = (void *)*(v11 - 25);
    if ( v13 )
    {
      ObfDereferenceObject(v13);
      *(v11 - 25) = 0i64;
    }
    v14 = (void *)*(v11 - 24);
    if ( v14 )
    {
      ObfDereferenceObject(v14);
      *(v11 - 24) = 0i64;
    }
    v15 = (void *)*(v11 - 23);
    if ( v15 )
    {
      ObfDereferenceObject(v15);
      *(v11 - 23) = 0i64;
    }
    *((_WORD *)v11 + 8) = 0;
    --*(_DWORD *)(a2 + 72);
  }
LABEL_28:
  KeReleaseSpinLock(v3, v8);
  if ( !v6 )
    return 3221225485i64;
  IoInvalidateDeviceRelations(*(PDEVICE_OBJECT *)(a2 + 40), BusRelations);
  return 0i64;
}

//----- (0000000140002B60) ----------------------------------------------------
void __fastcall sub_140002B60(__int64 a1, void *a2)
{
  KSPIN_LOCK *v2; // rdi
  KIRQL v5; // al
  _QWORD *v6; // r14
  __int64 v7; // rbx

  v2 = (KSPIN_LOCK *)(a1 + 80);
  v5 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(a1 + 80));
  v6 = (_QWORD *)(a1 + 56);
  while ( (_QWORD *)*v6 != v6 )
  {
    v7 = *v6 - 264i64;
    *(_WORD *)(v7 + 280) = 256;
    --*(_DWORD *)(a1 + 72);
    KeReleaseSpinLock(v2, v5);
    sub_140006F3C(*(PDEVICE_OBJECT *)v7, a2, v7);
    v5 = KeAcquireSpinLockRaiseToDpc(v2);
  }
  KeReleaseSpinLock(v2, v5);
}

//----- (0000000140002BF4) ----------------------------------------------------
void __fastcall sub_140002BF4(__int64 a1)
{
  __int64 v2; // rdi
  KIRQL v3; // al
  _QWORD *v4; // rbx
  __int64 v5; // r8
  _QWORD *v6; // rdx

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64i64);
  v3 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v2 + 80));
  v4 = (_QWORD *)(a1 + 264);
  v5 = *v4;
  v6 = (_QWORD *)v4[1];
  if ( *(_QWORD **)(*v4 + 8i64) != v4 || (_QWORD *)*v6 != v4 )
    __fastfail(3u);
  *v6 = v5;
  *(_QWORD *)(v5 + 8) = v6;
  if ( *(_QWORD *)(v2 + 56) == v2 + 56 )
    *(_DWORD *)(v2 + 160) = 0;
  KeReleaseSpinLock((PKSPIN_LOCK)(v2 + 80), v3);
}

//----- (0000000140002C6C) ----------------------------------------------------
void __fastcall CompletionFunction(
        PDEVICE_OBJECT DeviceObject,
        UCHAR MinorFunction,
        POWER_STATE PowerState,
        _QWORD *Context,
        PIO_STATUS_BLOCK IoStatus)
{
  PVOID DeviceExtension; // rsi
  __int64 v6; // rbx
  __int64 v8; // rax

  DeviceExtension = DeviceObject->DeviceExtension;
  v6 = Context[23];
  if ( PowerState.SystemState == PowerSystemWorking )
  {
    PoSetPowerState(DeviceObject, *(POWER_STATE_TYPE *)(v6 + 16), *(POWER_STATE *)(v6 + 24));
    *((_DWORD *)DeviceExtension + 5) = *(_DWORD *)(v6 + 24);
    *((_DWORD *)Context + 12) = IoStatus->Status;
    PoStartNextPowerIrp((PIRP)Context);
    IofCompleteRequest((PIRP)Context, 0);
    sub_1400014D0((__int64)DeviceExtension);
  }
  else
  {
    *(_OWORD *)(v6 - 72) = *(_OWORD *)v6;
    *(_OWORD *)(v6 - 56) = *(_OWORD *)(v6 + 16);
    *(_OWORD *)(v6 - 40) = *(_OWORD *)(v6 + 32);
    *(_QWORD *)(v6 - 24) = *(_QWORD *)(v6 + 48);
    *(_BYTE *)(v6 - 69) = 0;
    v8 = Context[23];
    *(_QWORD *)(v8 - 8) = 0i64;
    *(_QWORD *)(v8 - 16) = sub_140002DAC;
    *(_BYTE *)(v8 - 69) = -32;
    PoCallDriver(*((PDEVICE_OBJECT *)DeviceExtension + 6), (PIRP)Context);
  }
}

//----- (0000000140002D28) ----------------------------------------------------
void __fastcall sub_140002D28(
        PDEVICE_OBJECT DeviceObject,
        UCHAR MinorFunction,
        POWER_STATE PowerState,
        _QWORD *Context,
        PIO_STATUS_BLOCK IoStatus)
{
  __int64 v5; // rbx
  _DWORD *DeviceExtension; // rdi

  v5 = Context[23];
  DeviceExtension = DeviceObject->DeviceExtension;
  PoSetPowerState(DeviceObject, *(POWER_STATE_TYPE *)(v5 + 16), *(POWER_STATE *)(v5 + 24));
  DeviceExtension[5] = *(_DWORD *)(v5 + 24);
  *((_DWORD *)Context + 12) = IoStatus->Status;
  PoStartNextPowerIrp((PIRP)Context);
  IofCompleteRequest((PIRP)Context, 0);
}

//----- (0000000140002D88) ----------------------------------------------------
void __fastcall sub_140002D88(PDEVICE_OBJECT DeviceObject, UCHAR MinorFunction, POWER_STATE PowerState, char *Context)
{
  if ( !_InterlockedDecrement((volatile signed __int32 *)Context + 19) )
    KeSetEvent((PRKEVENT)(Context + 176), 1, 0);
}

//----- (0000000140002DAC) ----------------------------------------------------
__int64 __fastcall sub_140002DAC(__int64 a1, IRP *a2)
{
  __int64 v2; // rbx
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  ULONG Options; // r8d
  POWER_STATE v6; // eax
  unsigned int v7; // edi
  POWER_STATE v8; // r8d
  POWER_STATE_TYPE Type; // edx
  NTSTATUS v10; // eax

  v2 = *(_QWORD *)(a1 + 64);
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  Options = CurrentStackLocation->Parameters.Create.Options;
  v6.SystemState = (SYSTEM_POWER_STATE)CurrentStackLocation->Parameters.Power.State;
  v7 = 0;
  if ( CurrentStackLocation->MinorFunction == 2 )
  {
    if ( Options )
    {
      if ( Options != 1 )
      {
LABEL_11:
        PoStartNextPowerIrp(a2);
        sub_1400014D0(v2);
        return v7;
      }
      *(POWER_STATE *)(v2 + 200) = v6;
      v8.SystemState = v6.SystemState;
      Type = DevicePowerState;
    }
    else
    {
      if ( v6.SystemState <= *(_DWORD *)(v2 + 20) )
      {
        v10 = PoRequestPowerIrp(*(PDEVICE_OBJECT *)v2, 2u, (POWER_STATE)1, CompletionFunction, a2, 0i64);
        v7 = v10;
        if ( v10 == 259 )
          return (unsigned int)-1073741802;
        a2->IoStatus.Status = v10;
        goto LABEL_11;
      }
      *(POWER_STATE *)(v2 + 20) = v6;
      v8.SystemState = (SYSTEM_POWER_STATE)CurrentStackLocation->Parameters.Power.State;
      Type = CurrentStackLocation->Parameters.Power.Type;
    }
    PoSetPowerState(*(PDEVICE_OBJECT *)v2, Type, v8);
    goto LABEL_11;
  }
  return (unsigned int)-1073741637;
}

//----- (0000000140006000) ----------------------------------------------------
__int64 __fastcall sub_140006000(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned int v4; // ebx
  char v5; // cl

  v2 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a2 + 56) = 0i64;
  v4 = -1073741808;
  if ( *(_BYTE *)(v2 + 8) )
  {
    sub_14000151C(v2);
    if ( *(_DWORD *)(v2 + 12) == 6 )
    {
      v4 = -1073741738;
    }
    else
    {
      v5 = **(_BYTE **)(a2 + 184);
      if ( !v5 || v5 == 2 )
        v4 = 0;
    }
    sub_1400014D0(v2);
  }
  *(_DWORD *)(a2 + 48) = v4;
  IofCompleteRequest((PIRP)a2, 0);
  return v4;
}

//----- (000000014000607C) ----------------------------------------------------
__int64 __fastcall sub_14000607C(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned int v3; // ebx
  unsigned int *v5; // rcx
  _DWORD *v6; // r14
  unsigned int v7; // ebp
  __int64 v8; // r15
  __int64 *v9; // rax
  __int64 *v10; // rax
  unsigned int v11; // eax

  v2 = *(_QWORD *)(a1 + 64);
  v3 = 0;
  if ( *(_BYTE *)(v2 + 8) )
  {
    if ( *(_DWORD *)(v2 + 12) == 6 )
    {
      v3 = -1073741738;
      goto LABEL_5;
    }
    sub_14000151C(v2);
    v5 = *(unsigned int **)(a2 + 184);
    v6 = *(_DWORD **)(a2 + 24);
    v7 = v5[4];
    v8 = v5[2];
    if ( v5[6] == 2760704 )
    {
      if ( v7 == (_DWORD)v8 && v7 >= 0xBB && *v6 == 183 )
      {
        v11 = sub_1400069F4(*(_QWORD *)(a2 + 24), v7, v2);
        goto LABEL_24;
      }
    }
    else
    {
      if ( v5[6] != 2760708 )
      {
        switch ( v5[6] )
        {
          case 0x2A200Cu:
            v10 = sub_14000155C(v2, *(_DWORD *)(v2 + 164));
            if ( !v10 )
              goto LABEL_26;
            break;
          case 0x2A2010u:
            v10 = sub_14000155C(v2, *(_DWORD *)(v2 + 168));
            if ( !v10 )
            {
LABEL_26:
              *(_DWORD *)(a2 + 48) = v3;
              IofCompleteRequest((PIRP)a2, 0);
              sub_1400014D0(v2);
              return v3;
            }
            break;
          case 0x2A203Cu:
            v9 = sub_14000155C(v2, *(_DWORD *)(v2 + 172));
            if ( v9 )
              sub_140001C4C(*v9, v6, v7);
            goto LABEL_26;
          default:
            goto LABEL_25;
        }
        sub_140001D1C(*v10, v6, v7);
        goto LABEL_26;
      }
      if ( v7 == 20 && *v6 == 20 )
      {
        v11 = sub_1400029F0(*(_QWORD *)(a2 + 24), v2);
LABEL_24:
        *(_QWORD *)(a2 + 56) = v8;
        v3 = v11;
        goto LABEL_26;
      }
    }
LABEL_25:
    v3 = -1073741811;
    goto LABEL_26;
  }
  v3 = -1073741808;
LABEL_5:
  *(_DWORD *)(a2 + 48) = v3;
  IofCompleteRequest((PIRP)a2, 0);
  return v3;
}

//----- (00000001400061F4) ----------------------------------------------------
__int64 __fastcall sub_1400061F4(PDEVICE_OBJECT DeviceObject, _DWORD *Dst)
{
  struct _DEVICE_OBJECT *AttachedDeviceReference; // rsi
  PIRP v5; // rax
  IRP *v6; // rdi
  unsigned int Status; // ebx
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rbx
  struct _IO_STACK_LOCATION *v9; // rbx
  struct _IO_STACK_LOCATION *v10; // rax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+40h] [rbp-38h] BYREF
  struct _KEVENT Event; // [rsp+50h] [rbp-28h] BYREF

  memset(Dst, 0, 0x40ui64);
  *Dst = 65600;
  Dst[2] = -1;
  Dst[3] = -1;
  KeInitializeEvent(&Event, SynchronizationEvent, 0);
  AttachedDeviceReference = IoGetAttachedDeviceReference(DeviceObject);
  v5 = IoBuildSynchronousFsdRequest(0x1Bu, AttachedDeviceReference, 0i64, 0, 0i64, &Event, &IoStatusBlock);
  v6 = v5;
  if ( v5 )
  {
    CurrentStackLocation = v5->Tail.Overlay.CurrentStackLocation;
    v5->IoStatus.Information = 0i64;
    v5->IoStatus.Status = -1073741637;
    v9 = CurrentStackLocation - 1;
    if ( v9 )
    {
      memset(v9, 0, sizeof(struct _IO_STACK_LOCATION));
      *(_WORD *)&v9->MajorFunction = 2331;
      v9->Parameters.WMI.ProviderId = (ULONG_PTR)Dst;
      v10 = v6->Tail.Overlay.CurrentStackLocation;
      v10[-1].CompletionRoutine = 0i64;
      v10[-1].Context = 0i64;
      v10[-1].Control = 0;
      Status = IofCallDriver(AttachedDeviceReference, v6);
      if ( Status == 259 )
      {
        KeWaitForSingleObject(&Event, Executive, 0, 0, 0i64);
        Status = IoStatusBlock.Status;
      }
    }
    else
    {
      Status = -1073741811;
    }
  }
  else
  {
    Status = -1073741670;
  }
  ObfDereferenceObject(AttachedDeviceReference);
  return Status;
}

//----- (000000014000632C) ----------------------------------------------------
__int64 __fastcall sub_14000632C(struct _DEVICE_OBJECT *a1, IRP *a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // r10d
  unsigned int Status; // ebx
  unsigned int v8; // r10d
  unsigned int v9; // r10d
  unsigned int v10; // r10d
  unsigned int v11; // r10d
  unsigned int v12; // r10d
  unsigned int v13; // r10d
  unsigned int v14; // eax
  unsigned int v15; // r10d
  unsigned int v16; // r10d
  unsigned int v17; // r10d
  unsigned int v18; // r10d
  unsigned int v19; // r10d
  unsigned int v20; // r10d

  v4 = *(unsigned __int8 *)(a3 + 1);
  if ( v4 > 9 )
  {
    v15 = v4 - 10;
    if ( v15 )
    {
      v16 = v15 - 1;
      if ( v16 )
      {
        v17 = v16 - 1;
        if ( !v17 )
        {
          v14 = sub_1400067E4(a4, (__int64)a2);
          goto LABEL_18;
        }
        v18 = v17 - 7;
        if ( !v18 )
        {
          v14 = sub_140006578(a4, (__int64)a2);
          goto LABEL_18;
        }
        v19 = v18 - 2;
        if ( !v19 )
        {
          v14 = sub_140006460(a4, (__int64)a2);
          goto LABEL_18;
        }
        v20 = v19 - 1;
        if ( !v20 )
        {
          Status = -1073741822;
          goto LABEL_32;
        }
        if ( v20 == 1 )
        {
          *(_DWORD *)(a4 + 12) = 5;
          Status = 0;
          goto LABEL_32;
        }
      }
    }
    goto LABEL_31;
  }
  if ( v4 == 9 )
  {
    v14 = sub_1400064AC(a4, (__int64)a2);
    goto LABEL_18;
  }
  Status = 0;
  if ( !*(_BYTE *)(a3 + 1) )
    goto LABEL_16;
  v8 = v4 - 1;
  if ( v8 )
  {
    v9 = v8 - 1;
    if ( v9 )
    {
      v10 = v9 - 1;
      if ( !v10 )
      {
LABEL_16:
        *(_DWORD *)(a4 + 12) = 1;
        goto LABEL_32;
      }
      v11 = v10 - 1;
      if ( v11 )
      {
        v12 = v11 - 1;
        if ( v12 )
        {
          v13 = v12 - 1;
          if ( v13 )
          {
            if ( v13 == 1 )
            {
              v14 = sub_140006750((PVOID *)a4, (__int64)a2);
LABEL_18:
              Status = v14;
              goto LABEL_32;
            }
LABEL_31:
            Status = a2->IoStatus.Status;
            goto LABEL_32;
          }
          goto LABEL_16;
        }
        *(_DWORD *)(a4 + 12) = 2;
      }
      else
      {
        *(_DWORD *)(a4 + 12) = 3;
      }
    }
    else
    {
      Status = sub_140006F3C(a1, a2, a4);
      *(_DWORD *)(a4 + 12) = *(_BYTE *)(a4 + 280) == 0 ? 6 : 0;
    }
  }
  else
  {
    *(_DWORD *)(a4 + 12) = 4;
  }
LABEL_32:
  a2->IoStatus.Status = Status;
  IofCompleteRequest(a2, 0);
  return Status;
}

//----- (0000000140006460) ----------------------------------------------------
__int64 __fastcall sub_140006460(__int64 a1, __int64 a2)
{
  GUID *PoolWithTag; // rax

  PoolWithTag = (GUID *)ExAllocatePoolWithTag(PagedPool, 0x18ui64, 0x65626D77u);
  if ( !PoolWithTag )
    return 3221225626i64;
  *(_DWORD *)&PoolWithTag[1].Data2 = 0;
  PoolWithTag[1].Data1 = 15;
  *PoolWithTag = InterfaceClassGuid;
  *(_QWORD *)(a2 + 56) = PoolWithTag;
  return 0i64;
}

//----- (00000001400064AC) ----------------------------------------------------
__int64 __fastcall sub_1400064AC(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 result; // rax
  int v4; // eax
  int Dst[4]; // [rsp+20h] [rbp-58h] BYREF
  __int128 v6; // [rsp+30h] [rbp-48h]
  __int64 v7; // [rsp+40h] [rbp-38h]
  int v8; // [rsp+48h] [rbp-30h]

  v2 = *(_QWORD *)(*(_QWORD *)(a2 + 184) + 8i64);
  if ( *(_WORD *)(v2 + 2) != 1 )
    return 3221225659i64;
  result = sub_1400061F4(*(PDEVICE_OBJECT *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64i64) + 48i64), Dst);
  if ( (int)result >= 0 )
  {
    *(_OWORD *)(v2 + 16) = v6;
    *(_QWORD *)(v2 + 32) = v7;
    *(_DWORD *)(v2 + 40) = v8;
    if ( *(_DWORD *)(v2 + 20) != 1 )
      *(_DWORD *)(v2 + 20) = 1;
    if ( *(_DWORD *)(v2 + 24) != 4 )
      *(_DWORD *)(v2 + 24) = 4;
    if ( *(_DWORD *)(v2 + 28) != 4 )
      *(_DWORD *)(v2 + 28) = 4;
    if ( *(_DWORD *)(v2 + 32) != 4 )
      *(_DWORD *)(v2 + 32) = 4;
    v4 = *(_DWORD *)(v2 + 4);
    *(_QWORD *)(v2 + 44) = 0i64;
    *(_QWORD *)(v2 + 52) = 0i64;
    *(_DWORD *)(v2 + 60) = 0;
    *(_DWORD *)(v2 + 4) = v4 & 0xFFFFC12C | 0x290;
    return 0i64;
  }
  return result;
}
// 1400064AC: using guessed type int Dst[4];

//----- (0000000140006578) ----------------------------------------------------
__int64 __fastcall sub_140006578(__int64 a1, __int64 a2)
{
  int v3; // r8d
  unsigned int v5; // ebx
  struct _DEVICE_OBJECT *v6; // rcx
  wchar_t *v7; // rax
  wchar_t *v8; // rdi
  wchar_t *v9; // rax
  _OWORD *v10; // rax
  char *v11; // rdx
  char *v12; // rcx
  __int16 v13; // ax
  SIZE_T v14; // r14
  wchar_t *PoolWithTag; // rax
  unsigned int PropertyBuffer; // [rsp+68h] [rbp+10h] BYREF
  ULONG ResultLength; // [rsp+70h] [rbp+18h] BYREF

  v3 = *(_DWORD *)(*(_QWORD *)(a2 + 184) + 8i64);
  v5 = 0;
  if ( v3 < 0 )
    return *(unsigned int *)(a2 + 48);
  if ( v3 <= 1 )
  {
    v11 = *(char **)(a1 + 40);
    v12 = v11;
    while ( *(_WORD *)v12 )
    {
      v12 += 2;
      do
      {
        v13 = *(_WORD *)v12;
        v12 += 2;
      }
      while ( v13 );
    }
    v14 = 2 * (unsigned int)((v12 - v11 + 2) >> 1);
    PoolWithTag = (wchar_t *)ExAllocatePoolWithTag(PagedPool, v14, 0x65626D77u);
    v8 = PoolWithTag;
    if ( PoolWithTag )
    {
      memmove(PoolWithTag, *(const void **)(a1 + 40), v14);
      goto LABEL_19;
    }
    return (unsigned int)-1073741670;
  }
  if ( v3 != 2 )
  {
    if ( v3 == 3 )
    {
      v6 = *(struct _DEVICE_OBJECT **)(a1 + 72);
      if ( v6 )
      {
        PropertyBuffer = 0;
        ResultLength = 0;
        IoGetDeviceProperty(v6, DevicePropertyAddress, 4u, &PropertyBuffer, &ResultLength);
        v9 = (wchar_t *)ExAllocatePoolWithTag(PagedPool, 0x26ui64, 0x65626D77u);
        v8 = v9;
        if ( v9 )
        {
          swprintf(v9, L"AD_%x_%04x", PropertyBuffer, *(unsigned __int16 *)(a1 + 48));
          goto LABEL_19;
        }
      }
      else
      {
        v7 = (wchar_t *)ExAllocatePoolWithTag(PagedPool, 0xCui64, 0x65626D77u);
        v8 = v7;
        if ( v7 )
        {
          swprintf(v7, L"%02d", *(unsigned int *)(a1 + 256));
LABEL_19:
          *(_QWORD *)(a2 + 56) = v8;
          return v5;
        }
      }
      return (unsigned int)-1073741670;
    }
    return *(unsigned int *)(a2 + 48);
  }
  v10 = ExAllocatePoolWithTag(PagedPool, 0x54ui64, 0x65626D77u);
  if ( !v10 )
    return (unsigned int)-1073741670;
  *v10 = xmmword_140007430;
  v10[1] = xmmword_140007440;
  v10[2] = xmmword_140007450;
  v10[3] = xmmword_140007460;
  v10[4] = xmmword_140007470;
  *((_DWORD *)v10 + 20) = 0;
  *(_QWORD *)(a2 + 56) = v10;
  return v5;
}
// 140007430: using guessed type __int128 xmmword_140007430;
// 140007440: using guessed type __int128 xmmword_140007440;
// 140007450: using guessed type __int128 xmmword_140007450;
// 140007460: using guessed type __int128 xmmword_140007460;
// 140007470: using guessed type __int128 xmmword_140007470;

//----- (0000000140006750) ----------------------------------------------------
__int64 __fastcall sub_140006750(PVOID *a1, __int64 a2)
{
  unsigned int v4; // ebx
  void *v5; // rcx
  _QWORD *PoolWithTag; // rax
  _QWORD *v7; // rsi

  if ( *(_DWORD *)(*(_QWORD *)(a2 + 184) + 8i64) == 4 )
  {
    v5 = *(void **)(a2 + 56);
    v4 = 0;
    if ( v5 )
      ExFreePool(v5);
    PoolWithTag = ExAllocatePoolWithTag(PagedPool, 0x10ui64, 0x65626D77u);
    v7 = PoolWithTag;
    if ( PoolWithTag )
    {
      *(_DWORD *)PoolWithTag = 1;
      PoolWithTag[1] = *a1;
      ObfReferenceObject(*a1);
      *(_QWORD *)(a2 + 56) = v7;
    }
    else
    {
      return (unsigned int)-1073741670;
    }
  }
  else
  {
    return *(unsigned int *)(a2 + 48);
  }
  return v4;
}

//----- (00000001400067E4) ----------------------------------------------------
__int64 __fastcall sub_1400067E4(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  __int64 v5; // rcx
  __int64 v6; // rax
  wchar_t *PoolWithTag; // rax
  wchar_t *v8; // rsi

  v2 = 0;
  if ( *(_DWORD *)(*(_QWORD *)(a2 + 184) + 8i64) )
  {
    return *(unsigned int *)(a2 + 48);
  }
  else if ( !*(_QWORD *)(a2 + 56) )
  {
    v5 = -1i64;
    v6 = -1i64;
    do
      ++v6;
    while ( aLgvirhid[v6] );
    do
      ++v5;
    while ( aLogitech[v5] );
    PoolWithTag = (wchar_t *)ExAllocatePoolWithTag(PagedPool, (unsigned __int16)(2 * (v5 + 8 + v6)), 0x65626D77u);
    v8 = PoolWithTag;
    if ( PoolWithTag )
    {
      swprintf(PoolWithTag, L"%ws%ws%02d", L"Logitech_", L"LGVirHid", *(_DWORD *)(a1 + 256));
      *(_QWORD *)(a2 + 56) = v8;
    }
    else
    {
      return (unsigned int)-1073741670;
    }
  }
  return v2;
}
// 140007490: using guessed type wchar_t aLogitech[10];
// 1400074B0: using guessed type wchar_t aLgvirhid[9];

//----- (00000001400068B4) ----------------------------------------------------
NTSTATUS __fastcall sub_1400068B4(struct _DRIVER_OBJECT *a1, struct _DEVICE_OBJECT *a2)
{
  NTSTATUS result; // eax
  _QWORD *DeviceExtension; // rbx
  NTSTATUS v5; // edi
  PDEVICE_OBJECT v6; // rax
  PDEVICE_OBJECT SourceDevice; // [rsp+60h] [rbp+18h] BYREF

  result = IoCreateDevice(a1, 0xD0u, 0i64, 0x2Au, 0, 1u, &SourceDevice);
  if ( result >= 0 )
  {
    DeviceExtension = SourceDevice->DeviceExtension;
    memset(DeviceExtension, 0, 0xD0ui64);
    *((_DWORD *)DeviceExtension + 3) = 0;
    *((_DWORD *)DeviceExtension + 4) = dword_140004010;
    *((_BYTE *)DeviceExtension + 8) = 1;
    *DeviceExtension = SourceDevice;
    DeviceExtension[4] = SourceDevice;
    DeviceExtension[8] = DeviceExtension + 7;
    DeviceExtension[7] = DeviceExtension + 7;
    DeviceExtension[10] = 0i64;
    *((_DWORD *)DeviceExtension + 40) = 0;
    *((_DWORD *)DeviceExtension + 41) = 0;
    *((_DWORD *)DeviceExtension + 42) = 0;
    *((_DWORD *)DeviceExtension + 6) = 0;
    DeviceExtension[5] = a2;
    *((_DWORD *)DeviceExtension + 5) = 1;
    *((_DWORD *)DeviceExtension + 22) = 1;
    KeInitializeEvent((PRKEVENT)DeviceExtension + 4, SynchronizationEvent, 0);
    KeInitializeEvent((PRKEVENT)DeviceExtension + 5, SynchronizationEvent, 1u);
    SourceDevice->Flags |= 0x2000u;
    v5 = IoRegisterDeviceInterface(a2, &InterfaceClassGuid, 0i64, (PUNICODE_STRING)DeviceExtension + 9);
    if ( v5 >= 0 )
    {
      v6 = IoAttachDeviceToDeviceStack(SourceDevice, a2);
      DeviceExtension[6] = v6;
      if ( v6 )
      {
        SourceDevice->Flags &= ~0x80u;
        return v5;
      }
      v5 = -1073741670;
    }
    IoDeleteDevice(SourceDevice);
    return v5;
  }
  return result;
}
// 140004010: using guessed type int dword_140004010;

//----- (00000001400069F4) ----------------------------------------------------
NTSTATUS __fastcall sub_1400069F4(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ebp
  bool v6; // zf
  NTSTATUS result; // eax
  size_t v8; // r15
  NTSTATUS v9; // r14d
  PVOID DeviceExtension; // rsi
  char *PoolWithTag; // rax
  __int16 v12; // ax
  void *v13; // rcx
  void *v14; // rcx
  void *v15; // rcx
  int v16; // eax
  PDEVICE_OBJECT DeviceObject; // [rsp+70h] [rbp+8h] BYREF

  v3 = *(_DWORD *)(a1 + 148);
  if ( v3 >= 3 )
    return -1073741811;
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && *(_DWORD *)(a3 + 172) )
        return -1073741811;
      goto LABEL_11;
    }
    v6 = *(_DWORD *)(a3 + 168) == 0;
  }
  else
  {
    v6 = *(_DWORD *)(a3 + 164) == 0;
  }
  if ( !v6 )
    return -1073741811;
LABEL_11:
  v8 = *(unsigned int *)(a1 + 12);
  *(_DWORD *)(a1 + 8) = 1;
  if ( *(_WORD *)(a1 + 2i64 * (((unsigned int)v8 >> 1) - 1) + 16)
    || *(_WORD *)(a1 + 2i64 * (((unsigned int)v8 >> 1) - 2) + 16) )
  {
    return -1073741811;
  }
  result = IoCreateDevice(*(PDRIVER_OBJECT *)(*(_QWORD *)a3 + 8i64), 0x120u, 0i64, 0x2Au, 0x80u, 0, &DeviceObject);
  v9 = result;
  if ( result >= 0 )
  {
    DeviceExtension = DeviceObject->DeviceExtension;
    PoolWithTag = (char *)ExAllocatePoolWithTag((POOL_TYPE)512, (unsigned int)(v8 + *(_DWORD *)(a1 + 178)), 0x65626D77u);
    if ( PoolWithTag )
    {
      *((_QWORD *)DeviceExtension + 5) = PoolWithTag;
      *((_QWORD *)DeviceExtension + 12) = &PoolWithTag[v8];
      memmove(PoolWithTag, (const void *)(a1 + 16), v8);
      *((_DWORD *)DeviceExtension + 22) = *(_DWORD *)(a1 + 178);
      *((_WORD *)DeviceExtension + 25) = *(_WORD *)(a1 + 144);
      *((_WORD *)DeviceExtension + 24) = *(_WORD *)(a1 + 146);
      v12 = *(_WORD *)(a1 + 152);
      *((_DWORD *)DeviceExtension + 14) = v3;
      *((_WORD *)DeviceExtension + 26) = v12;
      v13 = *(void **)(a1 + 154);
      *((_QWORD *)DeviceExtension + 8) = v13;
      if ( v13 )
        ObfReferenceObject(v13);
      v14 = *(void **)(a1 + 162);
      *((_QWORD *)DeviceExtension + 9) = v14;
      if ( v14 )
        ObfReferenceObject(v14);
      v15 = *(void **)(a1 + 170);
      *((_QWORD *)DeviceExtension + 10) = v15;
      if ( v15 )
        ObfReferenceObject(v15);
      memmove(*((void **)DeviceExtension + 12), (const void *)(a1 + 182), *(unsigned int *)(a1 + 178));
      sub_140006DF0((__int64)DeviceObject, a3);
      *(_DWORD *)(a1 + 4) = *((_DWORD *)DeviceExtension + 64);
      v16 = *((_DWORD *)DeviceExtension + 14);
      if ( v16 )
      {
        if ( v16 == 1 )
        {
          *(_DWORD *)(a3 + 168) = *((_DWORD *)DeviceExtension + 64);
        }
        else if ( v16 == 2 )
        {
          *(_DWORD *)(a3 + 172) = *((_DWORD *)DeviceExtension + 64);
        }
      }
      else
      {
        *(_DWORD *)(a3 + 164) = *((_DWORD *)DeviceExtension + 64);
      }
      IoInvalidateDeviceRelations(*(PDEVICE_OBJECT *)(a3 + 40), BusRelations);
      return v9;
    }
    else
    {
      IoDeleteDevice(DeviceObject);
      return -1073741670;
    }
  }
  return result;
}

//----- (0000000140006C08) ----------------------------------------------------
__int64 __fastcall sub_140006C08(PDEVICE_OBJECT DeviceObject, PIRP Irp, __int64 a3, __int64 a4)
{
  unsigned int v9; // ebx
  int v10; // esi

  sub_14000151C(a4);
  if ( *(_BYTE *)(a3 + 1) )
  {
    switch ( *(_BYTE *)(a3 + 1) )
    {
      case 1:
        *(_DWORD *)(a4 + 12) = 4;
        break;
      case 2:
        if ( *(_DWORD *)(a4 + 12) != 5 )
          sub_140006EF0((struct _UNICODE_STRING *)a4);
        *(_DWORD *)(a4 + 12) = 6;
        sub_1400014D0(a4);
        sub_1400014D0(a4);
        KeWaitForSingleObject((PVOID)(a4 + 96), Executive, 0, 0, 0i64);
        sub_140002B60(a4, Irp);
        Irp->IoStatus.Status = 0;
        ++Irp->CurrentLocation;
        ++Irp->Tail.Overlay.CurrentStackLocation;
        v9 = IofCallDriver(*(PDEVICE_OBJECT *)(a4 + 48), Irp);
        IoDetachDevice(*(PDEVICE_OBJECT *)(a4 + 48));
        IoDeleteDevice(DeviceObject);
        return v9;
      case 3:
        goto LABEL_13;
      case 4:
        sub_1400014D0(a4);
        KeWaitForSingleObject((PVOID)(a4 + 120), Executive, 0, 0, 0i64);
        sub_14000151C(a4);
        *(_DWORD *)(a4 + 12) = 3;
        break;
      case 5:
        *(_DWORD *)(a4 + 12) = 2;
        break;
      case 6:
LABEL_13:
        *(_DWORD *)(a4 + 12) = 1;
        break;
      case 7:
        if ( !*(_DWORD *)(a3 + 8) )
          return sub_14000287C(a4, Irp);
        goto LABEL_22;
      case 0x17:
        sub_140006EF0((struct _UNICODE_STRING *)a4);
        *(_DWORD *)(a4 + 12) = 5;
        break;
      default:
LABEL_22:
        ++Irp->CurrentLocation;
        ++Irp->Tail.Overlay.CurrentStackLocation;
        v9 = IofCallDriver(*(PDEVICE_OBJECT *)(a4 + 48), Irp);
        sub_1400014D0(a4);
        return v9;
    }
    Irp->IoStatus.Status = 0;
    goto LABEL_22;
  }
  v10 = sub_140006FEC(*(PDEVICE_OBJECT *)(a4 + 48), Irp);
  if ( v10 >= 0 )
  {
    v10 = sub_140007094(a4);
    if ( v10 >= 0 )
      *(_DWORD *)(a4 + 12) = 1;
  }
  Irp->IoStatus.Status = v10;
  IofCompleteRequest(Irp, 0);
  sub_1400014D0(a4);
  return (unsigned int)v10;
}

//----- (0000000140006DF0) ----------------------------------------------------
void __fastcall sub_140006DF0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v4; // rax

  v2 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)v2 = a1;
  *(_BYTE *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 16) = dword_140004010;
  v4 = *(_QWORD *)a2;
  *(_DWORD *)(v2 + 12) = 0;
  *(_QWORD *)(v2 + 32) = v4;
  *(_WORD *)(v2 + 280) = 1;
  *(_DWORD *)(v2 + 256) = ++*(_DWORD *)(a2 + 160);
  *(_DWORD *)(v2 + 24) = 1;
  *(_DWORD *)(v2 + 20) = 1;
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 48) & 0xFFFFDF7F | 0x2000;
  IoInitializeRemoveLockEx((PIO_REMOVE_LOCK)(v2 + 128), 0x6C726562u, 0, 0, 0x20u);
  *(_QWORD *)(v2 + 104) = 0i64;
  *(_QWORD *)(v2 + 120) = v2 + 112;
  *(_QWORD *)(v2 + 112) = v2 + 112;
  sub_1400027B0(v2 + 160);
  sub_140002814(a2, v2);
}
// 140004010: using guessed type int dword_140004010;

//----- (0000000140006EA0) ----------------------------------------------------
__int64 __fastcall sub_140006EA0(struct _DEVICE_OBJECT *a1, IRP *a2)
{
  __int64 DeviceExtension; // r9
  __int64 CurrentStackLocation; // r8

  DeviceExtension = (__int64)a1->DeviceExtension;
  CurrentStackLocation = (__int64)a2->Tail.Overlay.CurrentStackLocation;
  if ( *(_DWORD *)(DeviceExtension + 12) == 6 )
  {
    a2->IoStatus.Status = -1073741738;
    IofCompleteRequest(a2, 0);
    return 3221225558i64;
  }
  else if ( *(_BYTE *)(DeviceExtension + 8) )
  {
    return sub_140006C08(a1, a2, CurrentStackLocation, DeviceExtension);
  }
  else
  {
    return sub_14000632C(a1, a2, CurrentStackLocation, DeviceExtension);
  }
}

//----- (0000000140006EF0) ----------------------------------------------------
__int64 __fastcall sub_140006EF0(struct _UNICODE_STRING *a1)
{
  struct _UNICODE_STRING *v2; // rbx
  __int64 result; // rax

  if ( a1[9].Buffer )
  {
    v2 = a1 + 9;
    IoSetDeviceInterfaceState(a1 + 9, 0);
    ExFreePool(a1[9].Buffer);
    result = 0i64;
    *(_QWORD *)&v2->Length = 0i64;
    v2->Buffer = 0i64;
  }
  return result;
}

//----- (0000000140006F3C) ----------------------------------------------------
__int64 __fastcall sub_140006F3C(PDEVICE_OBJECT DeviceObject, PVOID Tag, __int64 a3)
{
  void *v6; // rcx

  sub_140001B10(*(_QWORD *)a3);
  if ( !*(_BYTE *)(a3 + 280) && *(_BYTE *)(a3 + 281) )
  {
    sub_140002BF4(a3);
    IoAcquireRemoveLockEx((PIO_REMOVE_LOCK)(a3 + 128), Tag, byte_1400074F0, 1u, 0x20u);
    IoReleaseRemoveLockAndWaitEx((PIO_REMOVE_LOCK)(a3 + 128), Tag, 0x20u);
    v6 = *(void **)(a3 + 40);
    if ( v6 )
    {
      ExFreePool(v6);
      *(_QWORD *)(a3 + 40) = 0i64;
    }
    IoDeleteDevice(DeviceObject);
  }
  return 0i64;
}

//----- (0000000140006FEC) ----------------------------------------------------
NTSTATUS __fastcall sub_140006FEC(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rax
  struct _IO_STACK_LOCATION *v5; // rax
  NTSTATUS result; // eax
  struct _KEVENT Event; // [rsp+30h] [rbp-28h] BYREF

  KeInitializeEvent(&Event, SynchronizationEvent, 0);
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  *(_OWORD *)&CurrentStackLocation[-1].MajorFunction = *(_OWORD *)&CurrentStackLocation->MajorFunction;
  *(_OWORD *)&CurrentStackLocation[-1].Parameters.NotifyDirectoryEx.CompletionFilter = *(_OWORD *)&CurrentStackLocation->Parameters.NotifyDirectoryEx.CompletionFilter;
  *(_OWORD *)(&CurrentStackLocation[-1].Parameters.SetQuota + 6) = *(_OWORD *)(&CurrentStackLocation->Parameters.SetQuota
                                                                             + 6);
  CurrentStackLocation[-1].FileObject = CurrentStackLocation->FileObject;
  CurrentStackLocation[-1].Control = 0;
  v5 = Irp->Tail.Overlay.CurrentStackLocation;
  v5[-1].CompletionRoutine = (PIO_COMPLETION_ROUTINE)sub_140002780;
  v5[-1].Control = -32;
  v5[-1].Context = &Event;
  result = IofCallDriver(DeviceObject, Irp);
  if ( result == 259 )
  {
    KeWaitForSingleObject(&Event, Executive, 0, 0, 0i64);
    return Irp->IoStatus.Status;
  }
  return result;
}

//----- (0000000140007094) ----------------------------------------------------
NTSTATUS __fastcall sub_140007094(__int64 a1)
{
  NTSTATUS result; // eax

  result = IoSetDeviceInterfaceState((PUNICODE_STRING)(a1 + 144), 1u);
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 200) = 1;
  return result;
}

//----- (00000001400070C4) ----------------------------------------------------
__int64 __fastcall sub_1400070C4(char *Context, PIRP Irp)
{
  struct _IO_STACK_LOCATION *CurrentStackLocation; // r13
  ULONG Options; // r14d
  signed int LowPart; // ebx
  char v7; // r15
  signed int v8; // eax
  PDEVICE_OBJECT v9; // rbx
  char v10; // r15
  bool v11; // zf
  POWER_STATE v12; // ebx
  signed int v13; // eax
  struct _IO_STACK_LOCATION *v15; // rax
  struct _IO_STACK_LOCATION *v16; // rax
  unsigned int v17; // ebx

  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  Options = CurrentStackLocation->Parameters.Create.Options;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  v7 = 0;
  sub_14000151C((__int64)Context);
  if ( CurrentStackLocation->MinorFunction != 2 )
  {
    if ( CurrentStackLocation->MinorFunction == 3 )
      Irp->IoStatus.Status = 0;
    goto LABEL_24;
  }
  if ( Options )
  {
    if ( Options == 1 )
    {
      Irp->IoStatus.Status = 0;
      v8 = *((_DWORD *)Context + 50);
      if ( v8 != LowPart )
      {
        if ( v8 < LowPart )
        {
          *((_DWORD *)Context + 19) = *((_DWORD *)Context + 18);
          KeInitializeEvent((PRKEVENT)(Context + 176), SynchronizationEvent, 0);
          v9 = (PDEVICE_OBJECT)*((_QWORD *)Context + 7);
          if ( v9 != (PDEVICE_OBJECT)(Context + 56) )
          {
            v10 = 0;
            do
            {
              if ( LOBYTE(v9->NextDevice) )
              {
                if ( HIDWORD(v9->NextDevice) == 1 )
                {
                  v10 = 1;
                  PoRequestPowerIrp(
                    *(PDEVICE_OBJECT *)&v9[-1].DeviceType,
                    2u,
                    (POWER_STATE)4,
                    (PREQUEST_POWER_COMPLETE)sub_140002D88,
                    Context,
                    0i64);
                }
                else if ( !_InterlockedDecrement((volatile signed __int32 *)Context + 19) && v10 )
                {
                  KeSetEvent((PRKEVENT)(Context + 176), 1, 0);
                }
              }
              v9 = *(PDEVICE_OBJECT *)&v9->Type;
            }
            while ( v9 != (PDEVICE_OBJECT)(Context + 56) );
            v11 = v10 == 0;
            v7 = 0;
            if ( !v11 )
              KeWaitForSingleObject(Context + 176, Executive, 0, 0, 0i64);
          }
          v12.SystemState = (SYSTEM_POWER_STATE)CurrentStackLocation->Parameters.Power.State;
          PoSetPowerState(*(PDEVICE_OBJECT *)Context, DevicePowerState, v12);
          *((POWER_STATE *)Context + 50) = v12;
          goto LABEL_24;
        }
        goto LABEL_23;
      }
    }
  }
  else
  {
    v13 = *((_DWORD *)Context + 5);
    if ( v13 != LowPart )
    {
      if ( v13 < LowPart )
      {
        Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
        PoRequestPowerIrp(
          *(PDEVICE_OBJECT *)Context,
          2u,
          (POWER_STATE)4,
          (PREQUEST_POWER_COMPLETE)CompletionFunction,
          Irp,
          0i64);
        return 259i64;
      }
LABEL_23:
      v7 = 1;
    }
  }
LABEL_24:
  v15 = Irp->Tail.Overlay.CurrentStackLocation;
  *(_OWORD *)&v15[-1].MajorFunction = *(_OWORD *)&v15->MajorFunction;
  *(_OWORD *)&v15[-1].Parameters.NotifyDirectoryEx.CompletionFilter = *(_OWORD *)&v15->Parameters.NotifyDirectoryEx.CompletionFilter;
  *(_OWORD *)(&v15[-1].Parameters.SetQuota + 6) = *(_OWORD *)(&v15->Parameters.SetQuota + 6);
  v15[-1].FileObject = v15->FileObject;
  v15[-1].Control = 0;
  if ( v7 )
  {
    Irp->Tail.Overlay.CurrentStackLocation->Control |= 1u;
    v16 = Irp->Tail.Overlay.CurrentStackLocation;
    v16[-1].CompletionRoutine = (PIO_COMPLETION_ROUTINE)sub_140002DAC;
    v16[-1].Context = 0i64;
    v16[-1].Control = -32;
    PoCallDriver(*((PDEVICE_OBJECT *)Context + 6), Irp);
    return 259;
  }
  else
  {
    PoStartNextPowerIrp(Irp);
    v17 = PoCallDriver(*((PDEVICE_OBJECT *)Context + 6), Irp);
    sub_1400014D0((__int64)Context);
  }
  return v17;
}

//----- (0000000140007300) ----------------------------------------------------
__int64 __fastcall sub_140007300(__int64 a1, IRP *a2)
{
  struct _IO_STACK_LOCATION *CurrentStackLocation; // r8
  unsigned int v3; // edi
  UCHAR MinorFunction; // al
  POWER_STATE v6; // ebx
  ULONG Options; // edx
  unsigned int Status; // ebx
  __int64 result; // rax
  POWER_STATE v11; // r8d

  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  v3 = 0;
  MinorFunction = CurrentStackLocation->MinorFunction;
  v6.SystemState = (SYSTEM_POWER_STATE)CurrentStackLocation->Parameters.Power.State;
  Options = CurrentStackLocation->Parameters.Create.Options;
  if ( MinorFunction <= 1u )
  {
    v3 = -1073741637;
LABEL_14:
    PoStartNextPowerIrp(a2);
    a2->IoStatus.Status = v3;
    IofCompleteRequest(a2, 0);
    return v3;
  }
  if ( MinorFunction != 2 )
  {
    if ( MinorFunction != 3 )
    {
      Status = a2->IoStatus.Status;
      IofCompleteRequest(a2, 0);
      return Status;
    }
    goto LABEL_14;
  }
  if ( Options )
  {
    if ( Options == 1 )
    {
      PoSetPowerState(*(PDEVICE_OBJECT *)a1, DevicePowerState, v6);
      *(POWER_STATE *)(a1 + 284) = v6;
    }
    else
    {
      v3 = a2->IoStatus.Status;
    }
    goto LABEL_14;
  }
  CurrentStackLocation->Control |= 1u;
  v11.SystemState = PowerSystemSleeping3;
  if ( v6.SystemState == PowerSystemWorking )
    v11.SystemState = PowerSystemWorking;
  v3 = PoRequestPowerIrp(*(PDEVICE_OBJECT *)a1, 2u, v11, (PREQUEST_POWER_COMPLETE)sub_140002D28, a2, 0i64);
  result = 259i64;
  if ( v3 != 259 )
    goto LABEL_14;
  return result;
}

//----- (00000001400073E4) ----------------------------------------------------
__int64 __fastcall sub_1400073E4(__int64 a1, IRP *a2)
{
  char *v2; // rcx

  v2 = *(char **)(a1 + 64);
  if ( v2[8] )
    return sub_1400070C4(v2, a2);
  else
    return sub_140007300((__int64)v2, a2);
}

//----- (0000000140008000) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath)
{
  DriverObject->MajorFunction[2] = (PDRIVER_DISPATCH)sub_140006000;
  DriverObject->MajorFunction[0] = (PDRIVER_DISPATCH)sub_140006000;
  DriverObject->MajorFunction[27] = (PDRIVER_DISPATCH)sub_140006EA0;
  DriverObject->MajorFunction[22] = (PDRIVER_DISPATCH)sub_1400073E4;
  DriverObject->MajorFunction[14] = (PDRIVER_DISPATCH)sub_14000607C;
  DriverObject->MajorFunction[15] = (PDRIVER_DISPATCH)sub_140001700;
  DriverObject->MajorFunction[23] = (PDRIVER_DISPATCH)sub_140001540;
  DriverObject->DriverUnload = (PDRIVER_UNLOAD)nullsub_1;
  DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)sub_1400068B4;
  return 0;
}
// 140006078: using guessed type __int64 __fastcall nullsub_1();

// nfuncs=72 queued=61 decompiled=61 lumina nreq=0 worse=0 better=0
// ALL OK, 61 function(s) have been successfully decompiled
